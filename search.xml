<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>react-native-code-push热更新</title>
    <url>/2020/03/25/RN%E4%BD%BF%E7%94%A8CodePush%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p><a href="https://docs.microsoft.com/en-us/appcenter/distribution/codepush/" target="_blank" rel="noopener">官方链接</a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文测试都是基于以下配置进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info</span><br><span class="line">  React Native Environment Info:</span><br><span class="line">    System:</span><br><span class="line">      OS: macOS 10.14.5</span><br><span class="line">      CPU: (4) x64 Intel(R) Core(TM) i3-8100B CPU @ 3.60GHz</span><br><span class="line">      Memory: 192.60 MB / 8.00 GB</span><br><span class="line">      Shell: 5.3 - /bin/zsh</span><br><span class="line">    Binaries:</span><br><span class="line">      Node: 12.10.0 - /usr/local/bin/node</span><br><span class="line">      Yarn: 1.17.3 - ~/.yarn/bin/yarn</span><br><span class="line">      npm: 6.11.3 - /usr/local/bin/npm</span><br><span class="line">      Watchman: 4.9.0 - /usr/local/bin/watchman</span><br><span class="line">    SDKs:</span><br><span class="line">      iOS SDK:</span><br><span class="line">        Platforms: iOS 13.2, DriverKit 19.0, macOS 10.15, tvOS 13.2, watchOS 6.1</span><br><span class="line">      Android SDK:</span><br><span class="line">        API Levels: 23, 26, 27, 28</span><br><span class="line">        Build Tools: 23.0.1, 26.0.1, 27.0.3, 28.0.2, 28.0.3</span><br><span class="line">        System Images: android-23 | Intel x86 Atom_64, android-23 | Google APIs Intel x86 Atom, android-23 | Google APIs Intel x86 Atom_64, android-26 | Google APIs Intel x86 Atom, android-27 | Intel x86 Atom_64, android-27 | Google APIs Intel x86 Atom, android-27 | Google Play Intel x86 Atom, android-28 | Google Play Intel x86 Atom</span><br><span class="line">    IDEs:</span><br><span class="line">      Android Studio: 3.5 AI-191.8026.42.35.5977832</span><br><span class="line">      Xcode: 11.3.1/11C505 - /usr/bin/xcodebuild</span><br><span class="line">    npmPackages:</span><br><span class="line">      react: 16.8.3 =&gt; 16.8.3</span><br><span class="line">      react-native: 0.59.9 =&gt; 0.59.9</span><br><span class="line">    npmGlobalPackages:</span><br><span class="line">      react-native-cli: 2.0.1</span><br><span class="line">      react-native-demo-for-npm: 1.0.16</span><br><span class="line">      react-native-update-cli: 0.1.0</span><br></pre></td></tr></table></figure>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="1-Install-the-App-Center-CLI"><a href="#1-Install-the-App-Center-CLI" class="headerlink" title="1. Install the App Center CLI"></a>1. Install the App Center CLI</h3><p>要管理大多数<strong>CodePush</strong>功能，需要使用<strong>App Center CLI</strong>。通过以下命令安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g appcenter-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：官方提示，不要使用<code>sudo</code>权限来执行安装这个命令。</p>
</blockquote>
<p>在成功安装<strong>App Center CLI</strong>后，执行下面的命令来配置你的<strong>App Center</strong>账户详情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter login</span><br></pre></td></tr></table></figure>

<p>账户信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Logged in as wankeenergy-gmail.com</span><br></pre></td></tr></table></figure>

<h5 id="1-1-在App-Center上创建App"><a href="#1-1-在App-Center上创建App" class="headerlink" title="1.1 在App Center上创建App"></a>1.1 在App Center上创建App</h5><ul>
<li>iOS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps create -d PowerPlus-iOS -o iOS -p React-Native</span><br></pre></td></tr></table></figure>

<p>创建成功输出类似如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter apps create -d PowerPlus-iOS -o iOS -p React-Native</span><br><span class="line">App Secret:            28a33816-6bc0-4b00-8947-97b28e7780e4</span><br><span class="line">Description:</span><br><span class="line">Display Name:          PowerPlus-iOS</span><br><span class="line">Name:                  PowerPlus-iOS</span><br><span class="line">OS:                    iOS</span><br><span class="line">Platform:              React-Native</span><br><span class="line">Release Type:</span><br><span class="line">Owner ID:              20273273-6efd-459d-bb13-5cf102ba28d4</span><br><span class="line">Owner Display Name:    Energy Wanke</span><br><span class="line">Owner Email:           wankeenergy@gmail.com</span><br><span class="line">Owner Name:            wankeenergy-gmail.com</span><br><span class="line">Azure Subscription ID:</span><br></pre></td></tr></table></figure>

<ul>
<li>Android</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps create -d PowerPlus-Android -o Android -p React-Native</span><br></pre></td></tr></table></figure>

<p>我们可以把<strong>App Center</strong>上的应用程序<code>PowerPlus-iOS</code>设置为当前的应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps set-current wankeenergy-gmail.com/PowerPlus-iOS</span><br></pre></td></tr></table></figure>

<p>设置测试（<code>Staging</code>）)和 生产（<code>Production</code>）环境密钥，这样的话避免测试的时候应用到生产环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush deployment add -a &lt;ownerName&gt;/&lt;appName&gt; Staging</span><br><span class="line">appcenter codepush deployment add -a &lt;ownerName&gt;/&lt;appName&gt; Production</span><br></pre></td></tr></table></figure>

<p>由于我们刚才使用<code>appcenter apps set-current</code>设置了<code>PowerPlus-iOS</code>设置为当前的应用程序, 所以直接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush deployment add Staging</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter codepush deployment add Staging</span><br><span class="line">Deployment Staging has been created for wankeenergy-gmail.com/PowerPlus-iOS with key _aoveTNJlRogvD_AZL16sr1dYl-JIG-moOdTY</span><br></pre></td></tr></table></figure>

<p>部署生产环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter codepush deployment add Production</span><br><span class="line">Deployment Production has been created for wankeenergy-gmail.com/PowerPlus-iOS with key ZqjsB9UA9BX5KylIOgNU4lCkSlDwCRVZudOoH</span><br></pre></td></tr></table></figure>

<p>将当前应用程序设置成<code>Android</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps set-current wankeenergy-gmail.com/PowerPlus-Android</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter codepush deployment add Staging</span><br><span class="line">Deployment Staging has been created for wankeenergy-gmail.com/PowerPlus-Android with key tFRH5R1fNGA_BTQ_P4ixCiR4v6TsEUL4iSMZj</span><br><span class="line"></span><br><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter codepush deployment add Production</span><br><span class="line">Deployment Production has been created for wankeenergy-gmail.com/PowerPlus-Android with key Daj3dgNAeyKYFzAqWGWfoV9PggYm8eX76vbMC</span><br></pre></td></tr></table></figure>

<p>可以使用下面的命令来查看当前应用程序的部署<code>key</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter codepush deployment list --displayKeys</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>Staging</td>
<td>tFRH5R1fNGA_BTQ_P4ixCiR4v6TsEUL4iSMZj</td>
</tr>
<tr>
<td>Production</td>
<td>Daj3dgNAeyKYFzAqWGWfoV9PggYm8eX76vbMC</td>
</tr>
</tbody></table>
<p>如果想改变已命名的应用程序名，可以使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps update -n &lt;newName&gt; -a &lt;ownerName&gt;/&lt;appName&gt;</span><br></pre></td></tr></table></figure>

<p>要想从服务器上移除<code>app</code>，可以使用如下命令(要注意，如果删除，则无法再更新<code>app</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps delete -a &lt;ownerName&gt;/&lt;appName&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要列举所有在<strong>App Center</strong>服务器上的<code>app</code>，可以运行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter apps list</span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  SolarEnergy git:(dev_chenlong) ✗ appcenter apps list</span><br><span class="line">* wankeenergy-gmail.com/PowerPlus-Android (current app)</span><br><span class="line">  wankeenergy-gmail.com/PowerPlus-iOS</span><br></pre></td></tr></table></figure>

<p>回滚版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush rollback</span><br></pre></td></tr></table></figure>

<h3 id="2-CodePush-ify你的app"><a href="#2-CodePush-ify你的app" class="headerlink" title="2. CodePush-ify你的app"></a>2. CodePush-ify你的app</h3><p>添加<strong>CodePush client SDK</strong>到你的<code>app</code>，通过配置，从<strong>App Center</strong>中拉取所部署的<code>app</code>更新, 详情可参考</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/appcenter/distribution/codepush/react-native#getting-started" target="_blank" rel="noopener">React Native</a></li>
</ul>
<h5 id="2-1-开始"><a href="#2-1-开始" class="headerlink" title="2.1 开始"></a>2.1 开始</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save react-native-code-push@5.7.0</span><br></pre></td></tr></table></figure>

<p><code>Android</code>和<code>iOS</code>的配置方式有所不同，要注意的是，官方推荐为每一个平台单独创建一个<strong>CodePush</strong>应用程序。如果你想要看一下其他工程如何集成<strong>CodePush</strong>，可以看一下社区提供的一些样例<code>app</code>: <a href="https://docs.microsoft.com/en-us/appcenter/distribution/codepush/react-native#example-apps--starters" target="_blank" rel="noopener">example apps</a>。此外，如果你想快速熟悉<strong>CodePush + React Native</strong>，可以看一下这些人制作的视频：<a href="https://www.youtube.com/watch?v=uN0FRWk-YW8&feature=youtu.be" target="_blank" rel="noopener">Bilal Budhani</a>和<a href="https://www.youtube.com/watch?v=f6I9y7V-Ibk" target="_blank" rel="noopener">Deepak Sisodiya</a>。</p>
<h5 id="2-2-iOS设置（这里按RN版本小于0-6来安装，因为我是0-59-9）"><a href="#2-2-iOS设置（这里按RN版本小于0-6来安装，因为我是0-59-9）" class="headerlink" title="2.2 iOS设置（这里按RN版本小于0.6来安装，因为我是0.59.9）"></a>2.2 iOS设置（这里按RN版本小于0.6来安装，因为我是0.59.9）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native link react-native-code-push</span><br></pre></td></tr></table></figure>

<p>上面这个命令会提示输入一个部署<code>key</code>(这个<code>key</code>就是上面已经添加的<code>Staging</code>和<code>Production</code>)，可以按回车键忽略，后面再配置也可以，可以通过以下命令来获取部署<code>key</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush deployment list -a &lt;ownerName&gt;/&lt;appName&gt; --displayKeys</span><br></pre></td></tr></table></figure>

<h5 id="2-3-到这里之后，我们运行react-native-run-android可能会报错如下："><a href="#2-3-到这里之后，我们运行react-native-run-android可能会报错如下：" class="headerlink" title="2.3 到这里之后，我们运行react-native run-android可能会报错如下："></a>2.3 到这里之后，我们运行<code>react-native run-android</code>可能会报错如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:app:transformDexArchiveWithDexMergerForDebug&apos;.</span><br><span class="line">&gt; com.android.build.api.transform.TransformException: java.lang.RuntimeException: java.lang.RuntimeException: com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives:</span><br><span class="line">  The number of method references in a .dex file cannot exceed 64K.</span><br><span class="line">  Learn how to resolve this issue at https://developer.android.com/tools/building/multidex.html</span><br></pre></td></tr></table></figure>

<p>解决办法，在<code>android/app/build.gradle</code>下添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	defaultConfig &#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	   // Enabling multidex support.</span><br><span class="line">        multiDexEnabled true</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-在项目根组件添加CodePush"><a href="#2-4-在项目根组件添加CodePush" class="headerlink" title="2.4 在项目根组件添加CodePush"></a>2.4 在项目根组件添加CodePush</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import codePush from &quot;react-native-code-push&quot;;</span><br><span class="line"></span><br><span class="line">class MyApp extends Component &#123;</span><br><span class="line"></span><br><span class="line">	   componentDidMount() &#123;</span><br><span class="line">	   		  /* </span><br><span class="line">	   		    注意：如果我们分别在Android和iOS中配置了 Staging 和 Production 密钥，那么我们这里可以</span><br><span class="line">	   		         不需要deploymentKey！！！当然，要传也没有关系，传的话就是代表动态使用这个 deploymentKey，会覆</span><br><span class="line">	   		         盖在工程中配置的key，看个人的选择！</span><br><span class="line">	   		   */</span><br><span class="line">        	  const deploymentKey = isAndroid ? &apos;tFRH5R1fNGA_BTQ_P4ixCiR4v6TsEUL4iSMZj&apos; : &apos;_aoveTNJlRogvD_AZL16sr1dYl-JIG-moOdTY&apos;;</span><br><span class="line">        	  codePush.sync(&#123;</span><br><span class="line">                   updateDialog: false,</span><br><span class="line">                   installMode: codePush.InstallMode.ON_NEXT_RESTART,</span><br><span class="line">                   deploymentKey: deploymentKey,</span><br><span class="line">       	       &#125;, status =&gt; &#123;</span><br><span class="line">           		 	__DEV__ &amp;&amp; console.warn(`status: $&#123;status&#125;`)</span><br><span class="line">       	 	   &#125;, progress =&gt; &#123;</span><br><span class="line">           		 	const &#123;totalBytes, receivedBytes&#125; = progress;</span><br><span class="line">            		__DEV__ &amp;&amp; console.warn(`totalBytes: $&#123;totalBytes&#125;, receivedBytes: $&#123;receivedBytes&#125;`);</span><br><span class="line">        	   &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyApp = codePush(MyApp);</span><br></pre></td></tr></table></figure>

<h3 id="3-部署测试和生产环境密钥进行多端测试"><a href="#3-部署测试和生产环境密钥进行多端测试" class="headerlink" title="3. 部署测试和生产环境密钥进行多端测试"></a>3. 部署测试和生产环境密钥进行多端测试</h3><p><a href="https://docs.microsoft.com/en-us/appcenter/distribution/codepush/react-native#multi-deployment-testing" target="_blank" rel="noopener">Multi-Deployment Testing</a></p>
<h3 id="4-发布app更新"><a href="#4-发布app更新" class="headerlink" title="4. 发布app更新"></a>4. 发布app更新</h3><p>注意：<code>Android</code>打包测试热更新的时候用下面这个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./gradlew assembleReleaseStaging</span><br></pre></td></tr></table></figure>

<p>如果用<code>./gradlew assembleRelease</code>的话，默认走的是<code>Production</code>。</p>
<p>如果需要直接在本地调试安装在<code>android</code>手机上的<code>Staging</code>版本，可以执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native run-android --variant=releaseStaging</span><br></pre></td></tr></table></figure>

<p><code>iOS</code>打包需要在<code>archive</code>的时候选择<code>Staging</code>，否则打的也是<code>Production</code>。</p>
<p>在更新代码后，使用<strong>App Center CLI</strong>发布更新到<strong>App Center</strong>，根据下面发布即可</p>
<h5 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h5><p>执行<strong>App Center CLI</strong>的<code>release-react</code>命令来打包代码和<code>asset</code>文件，然后发布到<strong>App Center server</strong>作为一个新的发布。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush release-react -a &lt;ownerName&gt;/MyApp</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>App Center CLI</strong>的一个重要特性就是可以使用<code>appcenter apps set-current &lt;ownerName&gt;/&lt;appName&gt;</code>把一个<code>app</code>设置为当前的<code>app</code>. 通过把<code>app</code>设置为当前<code>app</code>，就没有必要使用<code>-a</code>标志。例如，命令<code>appcenter codepush deployment list -a &lt;ownerName&gt;/&lt;appName&gt;</code>可以用<code>appcenter codepush deployment list</code>来代替。你也可以使用命令<code>appcenter apps get-current</code>来查看哪个<code>app</code>被设置成你账号的当前<code>app</code>。</p>
</blockquote>
<p>发布一个更新(加<code>-m</code>就是强制更新，会立即重启<code>app</code>)，并带有日志描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 强制立即重启</span><br><span class="line">appcenter codepush release-react -a &lt;ownerName&gt;/MyApp-iOS  -m --description &quot;Modified the header color&quot;</span><br><span class="line"></span><br><span class="line">// 不强制立即重启</span><br><span class="line">appcenter codepush release-react -a &lt;ownerName&gt;/MyApp-iOS  --description &quot;Modified the header color&quot;</span><br></pre></td></tr></table></figure>

<p>发布更新到具体的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush release-react -a &lt;ownerName&gt;/MyApp-Android  --target-binary-version &quot;1.1.0&quot;</span><br></pre></td></tr></table></figure>

<p>也可以指定范围要发布到哪些版本，参数如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Range Expression	Who gets the update</span><br><span class="line">1.2.3				Only devices running the specific binary version 1.2.3 of your app</span><br><span class="line">*	    			Any device configured to consume updates from your CodePush app</span><br><span class="line">1.2.x				Devices running major version 1, minor version 2, and any patch version of your app</span><br><span class="line">1.2.3 - 1.2.7		Devices running any binary version between 1.2.3 (inclusive) and 1.2.7 (inclusive)</span><br><span class="line">&gt;=1.2.3 &lt;1.2.7		Devices running any binary version between 1.2.3 (inclusive) and 1.2.7 (exclusive)</span><br><span class="line">1.2	    			Equivalent to &gt;=1.2.0 &lt;1.3.0</span><br><span class="line">~1.2.3				Equivalent to &gt;=1.2.3 &lt;1.3.0</span><br><span class="line">^1.2.3				Equivalent to &gt;=1.2.3 &lt;2.0.0</span><br></pre></td></tr></table></figure>

<p>要发布到生产环境还是测试环境，可以使用<code>--deployment-name 或 -d</code>，默认是<code>Staging</code>, 例如要发布到版本<code>1.1.0</code>的生产环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appcenter codepush release-react -a &lt;ownerName&gt;/MyApp-Android  --target-binary-version &quot;1.1.0&quot; --deployment-name Production</span><br></pre></td></tr></table></figure>

<h3 id="5-运行你的app"><a href="#5-运行你的app" class="headerlink" title="5. 运行你的app"></a>5. 运行你的app</h3><p>一旦这些步骤完成，所有运行<code>app</code>的用户都会收到更新。</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native, react-native-code-push, 热更新</tag>
      </tags>
  </entry>
  <entry>
    <title>RN集成Google Maps</title>
    <url>/2020/03/14/RN%E9%9B%86%E6%88%90Google%20Maps/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React Native Environment Info:</span><br><span class="line">  System:</span><br><span class="line">    OS: macOS 10.14.5</span><br><span class="line">    CPU: (4) x64 Intel(R) Core(TM) i3-8100B CPU @ 3.60GHz</span><br><span class="line">    Memory: 53.88 MB / 8.00 GB</span><br><span class="line">    Shell: 5.3 - /bin/zsh</span><br><span class="line">  Binaries:</span><br><span class="line">    Node: 12.10.0 - /usr/local/bin/node</span><br><span class="line">    Yarn: 1.17.3 - ~/.yarn/bin/yarn</span><br><span class="line">    npm: 6.11.3 - /usr/local/bin/npm</span><br><span class="line">    Watchman: 4.9.0 - /usr/local/bin/watchman</span><br><span class="line">  SDKs:</span><br><span class="line">    iOS SDK:</span><br><span class="line">      Platforms: iOS 12.2, macOS 10.14, tvOS 12.2, watchOS 5.2</span><br><span class="line">    Android SDK:</span><br><span class="line">      API Levels: 23, 26, 27, 28</span><br><span class="line">      Build Tools: 23.0.1, 26.0.1, 27.0.3, 28.0.2, 28.0.3</span><br><span class="line">      System Images: android-23 | Intel x86 Atom_64, android-23 | Google APIs Intel x86 Atom, android-23 | Google APIs Intel x86 Atom_64, android-26 | Google APIs Intel x86 Atom, android-27 | Intel x86 Atom_64, android-27 | Google APIs Intel x86 Atom, android-27 | Google Play Intel x86 Atom, android-28 | Google Play Intel x86 Atom</span><br><span class="line">  IDEs:</span><br><span class="line">    Android Studio: 3.5 AI-191.8026.42.35.5977832</span><br><span class="line">    Xcode: 10.2.1/10E1001 - /usr/bin/xcodebuild</span><br><span class="line">  npmPackages:</span><br><span class="line">    react: 16.8.3 =&gt; 16.8.3</span><br><span class="line">    react-native: 0.59.9 =&gt; 0.59.9</span><br><span class="line">  npmGlobalPackages:</span><br><span class="line">    react-native-cli: 2.0.1</span><br><span class="line">    react-native-demo-for-npm: 1.0.16</span><br><span class="line">    react-native-update-cli: 0.1.0</span><br></pre></td></tr></table></figure>

<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li><ol>
<li>安装</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install react-native-maps@0.25.0</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>在android/settings.gradle中添加如下内容：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rootProject.name = &apos;AndroidGoogleMaps&apos; </span><br><span class="line">include &apos;:react-native-maps&apos; </span><br><span class="line">project(&apos;:react-native-maps&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-maps/lib/android&apos;)</span><br><span class="line">include &apos;:app&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>在<code>android/app/build.gradle</code>添加：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])</span><br><span class="line">    implementation &quot;com.android.support:appcompat-v7:$&#123;rootProject.ext.supportLibVersion&#125;&quot;</span><br><span class="line">    implementation &quot;com.facebook.react:react-native:+&quot;  // From node_modules</span><br><span class="line">    implementation project(&apos;:react-native-maps&apos;) // 添加这行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>在<code>android/build.gradle</code>添加：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">       buildToolsVersion = &quot;28.0.3&quot;</span><br><span class="line">       minSdkVersion = 16</span><br><span class="line">       compileSdkVersion = 28</span><br><span class="line">       targetSdkVersion = 28</span><br><span class="line">       supportLibVersion = &quot;28.0.0&quot;</span><br><span class="line">       playServicesVersion = &quot;16.0.0&quot;  // 添加这行</span><br><span class="line">       androidMapsUtilsVersion=&quot;0.5+&quot;  // 添加这行</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="5">
<li>在<code>android/app/src/main/AndroidManifest.xml</code>添加</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">      .......</span><br><span class="line">	&lt;meta-data android:name=&quot;com.google.android.geo.API_KEY&quot; android:value=&quot;AIzaSyAZ7eaTLpbEmz7xWGst_-pSXYcv9SU6D_u&quot;/&gt;</span><br><span class="line">	&lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加 <code>&lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot;/&gt;</code>的原因是： Android翻墙后，会奔溃：<a href="https://github.com/react-native-community/react-native-maps/issues/2991#issuecomment-516765727" target="_blank" rel="noopener">https://github.com/react-native-community/react-native-maps/issues/2991#issuecomment-516765727</a>。</p>
</blockquote>
<ul>
<li><ol start="6">
<li>在<code>MainApplication.java</code>中添加</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.airbnb.android.react.maps.MapsPackage;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected List&lt;ReactPackage&gt; getPackages() &#123;</span><br><span class="line">      return Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">          new MainReactPackage(),</span><br><span class="line">          new MapsPackage()  // 添加这行</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="7">
<li>在App.js文件中添加以下内容：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import MapView from &apos;react-native-maps&apos;;</span><br><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  StyleSheet,</span><br><span class="line">  Dimensions,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    position: &apos;absolute&apos;,</span><br><span class="line">    top: 0,</span><br><span class="line">    left: 0,</span><br><span class="line">    right: 0,</span><br><span class="line">    bottom: 0,</span><br><span class="line">    justifyContent: &apos;flex-end&apos;,</span><br><span class="line">    alignItems: &apos;center&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  map: &#123;</span><br><span class="line">    // ...StyleSheet.absoluteFillObject</span><br><span class="line">    position: &apos;absolute&apos;,</span><br><span class="line">    top: 0,</span><br><span class="line">    left: 0,</span><br><span class="line">    right: 0,</span><br><span class="line">    bottom: 0,</span><br><span class="line">    //   width: Dimensions.get(&apos;window&apos;).width,</span><br><span class="line">    //   height: 500,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个工程，只集成、测试过Android， 并且必须翻墙，一些配置需要参考这里面的。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;MapView</span><br><span class="line">            style=&#123;styles.map&#125;</span><br><span class="line">            initialRegion=&#123;&#123;</span><br><span class="line">              latitude: 30.2,</span><br><span class="line">              longitude: 120.2,</span><br><span class="line">              latitudeDelta: 0.0922,</span><br><span class="line">              longitudeDelta: 0.0421,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><ul>
<li><ol>
<li>链接</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native link react-native-maps</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>在<code>AppDelegate.m</code>中添加</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;GoogleMaps/GoogleMaps.h&gt;</span><br><span class="line">[GMSServices provideAPIKey:@&quot;AIzaSyAZ7eaTLpbEmz7xWGst_-pSXYcv9SU6D_u&quot;];</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>手动集成<code>Google Maps SDK</code></li>
</ol>
</li>
</ul>
<p><a href="https://developers.google.com/maps/documentation/ios-sdk/start" target="_blank" rel="noopener">Google Maps Platform iOS SDK Manually</a></p>
<p>1.下载SDK（这里下载的是GoogleMaps-3.7.0）</p>
<p>2.解包SDK</p>
<p>3.打开xcode</p>
<p>4.将下面解压的文件拖到工程里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GoogleMaps-x.x.x/Base/Frameworks/GoogleMapsBase.framework</span><br><span class="line">GoogleMaps-x.x.x/Maps/Frameworks/GoogleMaps.framework</span><br><span class="line">GoogleMaps-x.x.x/Maps/Frameworks/GoogleMapsCore.framework</span><br></pre></td></tr></table></figure>

<p>5.右键<code>GoogleMaps.framework</code> -&gt; <code>Show In Finder</code></p>
<p>6.将<code>Resources/GoogleMaps.bundle</code>拖入工程，并且勾选<code>Create Folder References</code></p>
<p>7.在<code>Build Phases/Link Binary With Libraries</code>中添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GoogleMapsBase.framework</span><br><span class="line">GoogleMaps.framework</span><br><span class="line">GoogleMapsCore.framework</span><br><span class="line">Accelerate.framework</span><br><span class="line">CoreData.framework</span><br><span class="line">CoreGraphics.framework</span><br><span class="line">CoreImage.framework</span><br><span class="line">CoreLocation.framework</span><br><span class="line">CoreTelephony.framework</span><br><span class="line">CoreText.framework</span><br><span class="line">GLKit.framework</span><br><span class="line">ImageIO.framework</span><br><span class="line">libc++.tbd</span><br><span class="line">libz.tbd</span><br><span class="line">OpenGLES.framework</span><br><span class="line">QuartzCore.framework</span><br><span class="line">SystemConfiguration.framework</span><br><span class="line">UIKit.framework</span><br></pre></td></tr></table></figure>

<p>8.在<code>Info.plist</code>中添加隐私定位描述</p>
<p>9.在<code>package.json</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,</span><br><span class="line">    &quot;postinstall&quot;: &quot;./node_modules/react-native-maps/enable-google-maps &apos;./ios/**&apos;&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>10.执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>


<p>经过以上步骤，基本就能在<code>Android</code>和<code>iOS</code>端显示谷歌地图了。要注意的是，需要申请相应的<code>key</code>，需要到谷歌云平台申请，并且现在谷歌要求信用卡验证账号才可以使用，部分<code>API</code>需要收费，但是开始会有一定的免费额度，总的来说很多<code>API</code>比较贵。</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native, Google Maps, 谷歌地图</tag>
      </tags>
  </entry>
  <entry>
    <title>【iOS】真机调试,The executable was signed with invalid entitlements</title>
    <url>/2020/02/27/%5BiOS%5D%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95-The%20executable%20was%20signed%20with%20invalid%20entitlements./</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>昨天新创建了一个<code>Demo</code>工程，准备测试<code>iOS</code>的<code>Access WiFi Information</code>权限功能，使用<code>iPhone X</code>真机调试的时候，发现根本没法运行，于是将<code>Access WiFi Information</code>权限关掉，并且删除了之前打开<code>Access WiFi Information</code>权限而自动生成的<code>xxx.entitlements</code>权限证书文件，发现还是一样的报错。在一个新工程上面真机调试竟然报错？到底是哪里出了问题呢？</p>
<p>经过一天的调试，尝试了各种能想到的办法，以及在网上百度了一些资料，仍然没有解决…..</p>
<p>错误信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The executable was signed with invalid entitlements.</span><br><span class="line"></span><br><span class="line">The entitlements specified in your application’s Code Signing Entitlements file are invalid, </span><br><span class="line">not permitted, or do not match those specified in your provisioning profile. (0xE8008016).</span><br></pre></td></tr></table></figure>

<p>错误信息截图</p>
<p><img src="https://i.loli.net/2020/02/27/qfeY1iA3QUBDgZr.png" alt="error.png"></p>
<p>今天调整心态，使用<code>Google</code>查找，终于在<strong>stack overflow</strong>找到了问题所在</p>
<p>答案链接：<a href="https://stackoverflow.com/a/54902044" target="_blank" rel="noopener">Entitlements file do not match those specified in your provisioning profile.(0xE8008016)</a></p>
<p>答案截图</p>
<p><img src="https://i.loli.net/2020/02/27/rW9oAV4Gd6KOmpY.png" alt="answer.png"></p>
<p>原来是项目（这里就以我的<code>demo</code>工程名为例）的<strong>wifidemo</strong>与<strong>wifidemoTests</strong>所选择的开发者团队名不一样所致，看了一下自己的工程，的确不同，于是按照这个回答将其改为一直就好了。</p>
<p><strong>图一</strong></p>
<p><img src="https://i.loli.net/2020/02/27/MO4PSyeAnjXCcup.png" alt="wifidemo.png"></p>
<p><strong>图二</strong><br><img src="https://i.loli.net/2020/02/27/en9GZPgtfXQkrOM.png" alt="wifidemoTests.png"></p>
<p>注：<em>图一</em>和<em>图二</em>红框中的<code>Team</code>请保持一致，即可解决以上出现的问题。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>真机调试报错</tag>
        <tag>entitlements</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用GitHub Packages创建npm私有库</title>
    <url>/2019/12/31/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GitHub%20Packages%E5%88%9B%E5%BB%BAnpm%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>GitHub Packages</code>是<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>提供的类似<code>npm</code>包管理工具或平台，通过<code>GitHub Packages</code>，我们可以直接使用<code>npm</code>相关的命令、功能，并且不用将自己的<code>npm</code>包发布到<code>npm</code>仓库。也就是说，我们的<code>npm</code>包将托管在<code>github</code>上，并且可以和我们相应的仓库保持同步。之前，我们介绍了<a href="https://www.clcoder.com/2019/12/18/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E5%88%B0npm%E5%AE%98%E6%96%B9%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">如何发布代码到npm官方仓库</a>、<a href="https://www.clcoder.com/2019/12/20/verdaccio%20+%20ngrok%E5%8F%91%E5%B8%83npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/#more" target="_blank" rel="noopener">verdaccio+ngrok发布npm私有仓库</a>以及<a href="https://www.clcoder.com/2019/12/23/%E5%9F%BA%E4%BA%8Egithub%E5%AE%9E%E7%8E%B0npm%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/#more" target="_blank" rel="noopener">基于github实现npm私有库的搭建</a>，通过这篇文章：<a href="https://www.clcoder.com/2019/12/23/%E5%9F%BA%E4%BA%8Egithub%E5%AE%9E%E7%8E%B0npm%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/#more" target="_blank" rel="noopener">基于github实现npm私有库的搭建</a>可以知道，我们可以创建自己的<code>npm私有库</code>，但是我们只能通过链接的方式安装<code>npm私有包</code>，不能使用<code>npm</code>的相关命令，比如<code>npm version patch</code>等等。今天，我们还继续讲<code>npm私有库</code>，还是基于<code>github</code>，与<a href="https://www.clcoder.com/2019/12/23/%E5%9F%BA%E4%BA%8Egithub%E5%AE%9E%E7%8E%B0npm%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/#more" target="_blank" rel="noopener">基于github实现npm私有库的搭建</a>不同的是，今天我们要讲的<code>npm私有库</code>是<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>官方于<code>2019年5月</code>推出的<code>GitHub Packages</code><strong>–</strong><code>类似npm包管理器</code>，通过<code>GitHub Packages</code>，我们不仅可以创建<code>npm私有包</code>，使用私有仓库，并且还可以使用<code>npm</code>的相关命令，也能通过以包名的形式来安装依赖，更重要的是，我们还可以将多个包（<code>packages</code>）放在同一个私有仓库当中，这样就可以统一管理，而不必一个<code>npm私有包</code>对应一个<code>github仓库</code>，简直太完美了。</p>
<p><code>GitHub Packages</code>看起来是这个样子</p>
<p><img src="https://i.loli.net/2019/12/26/jED1BaIKRfrx2sW.png" alt="github packages.png"></p>
<h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://i.loli.net/2019/12/26/3QG9BJF2VOEoLTn.png" alt="create repo.png"></p>
<h3 id="私有仓库看起来是下面这个样子"><a href="#私有仓库看起来是下面这个样子" class="headerlink" title="私有仓库看起来是下面这个样子"></a>私有仓库看起来是下面这个样子</h3><p><img src="https://i.loli.net/2019/12/26/E2f1OPhBr76Qvpj.png" alt="repo like.png"></p>
<blockquote>
<p>如果你还是不清楚怎么创建私有仓库，那就只能自己<code>Google</code>或者<code>百度</code>了。</p>
</blockquote>
<h3 id="克隆私有仓库到本地"><a href="#克隆私有仓库到本地" class="headerlink" title="克隆私有仓库到本地"></a>克隆私有仓库到本地</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:lchenfox/npm-repo.git</span><br></pre></td></tr></table></figure>

<h2 id="创建Personal-access-tokens"><a href="#创建Personal-access-tokens" class="headerlink" title="创建Personal access tokens"></a>创建Personal access tokens</h2><h3 id="进入github设置，点击Developer-settings"><a href="#进入github设置，点击Developer-settings" class="headerlink" title="进入github设置，点击Developer settings"></a>进入github设置，点击Developer settings</h3><p><img src="https://i.loli.net/2019/12/26/cpW3nwZOIirz6G4.png" alt="dev setting.png"></p>
<h3 id="依次点击1、2"><a href="#依次点击1、2" class="headerlink" title="依次点击1、2"></a>依次点击1、2</h3><p><img src="https://i.loli.net/2019/12/26/8hoPaexlVy9f3US.png" alt="tokens.png"></p>
<h3 id="如下图，然后往下滑，点击底部按钮-Generate-token"><a href="#如下图，然后往下滑，点击底部按钮-Generate-token" class="headerlink" title="如下图，然后往下滑，点击底部按钮 Generate token"></a>如下图，然后往下滑，点击底部按钮 <code>Generate token</code></h3><p><img src="https://i.loli.net/2019/12/26/aUNoGV7lFWCS3mn.png" alt="generate token.png"></p>
<h3 id="保存token"><a href="#保存token" class="headerlink" title="保存token"></a>保存token</h3><p><img src="https://i.loli.net/2019/12/26/IgfBTxej6n4C7Sl.png" alt="save token.png"></p>
<blockquote>
<p>注意：图中红框的<code>token</code>必须保存，因为<strong>只会在生成的时候显示一次</strong>，后面你是看不到的，而这个<code>token</code>一定会用到！！！</p>
</blockquote>
<h2 id="创建npm包"><a href="#创建npm包" class="headerlink" title="创建npm包"></a>创建npm包</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://i.loli.net/2019/12/26/TlPvWEz5cH2ZDhS.png" alt="init.png"></p>
<p>命令<code>npm init --scope=lchenfox</code>中的<code>lchenfox</code>必须是你的<code>github</code>用户名，其他随便填写一些<code>description</code>和<code>author</code>，然后一路回车就好。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>有<code>2</code>中配置方式，第一种是在<code>package.json</code>所在目录创建一个<code>.npmrc</code>文件，另一种方式是直接修改<code>package.json</code>文件并增加<code>publishConfig</code>项，任选其一即可。</p>
<ul>
<li>方式1， 创建<code>.npmrc</code>（推荐）</li>
</ul>
<p>创建<code>.npmrc</code>文件，并添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://npm.pkg.github.com/lchenfox</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再次提醒一次，<code>lchenfox</code>是你的<code>github</code>用户名。</p>
</blockquote>
<ul>
<li>方式2， 添加<code>publishConfig</code></li>
</ul>
<p>在<code>package.json</code>中添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;registry&quot;:&quot;https://npm.pkg.github.com/&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>添加后<code>package.json</code>看起来内容类似下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@lchenfox/npm-repo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A npm demo&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https://github.com/lchenfox/npm-repo.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;registry&quot;:&quot;https://npm.pkg.github.com/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/lchenfox/npm-repo/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/lchenfox/npm-repo#readme&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul>
<li>方式1（推荐）</li>
</ul>
<p>刚才已经创建了<code>.npmrc</code>文件，现在为了授权，我们可以继续添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</span><br></pre></td></tr></table></figure>

<p>添加以后，<code>.npmrc</code>内容应该包含两行，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://npm.pkg.github.com/lchenfox</span><br><span class="line">//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</code>是<code>token</code>，另外前缀<code>//</code>一定不能少，否则授权一定失败。事实上，无论是发布<code>npm包</code>还是在项目里面安装<code>npm包</code>，当前目录下的<code>.npmrc</code>里面的<code>//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</code>只针对当前<code>npm</code>包或当前项目有效，你在另一个<code>npm</code>包目录下或另一个项目下是不生效的。比如，如果在<code>first-package</code>目录下的<code>.npmrc</code>中添加<code>//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</code>的话，你在<code>second-package</code>里面也必须单独添加来授权特定的包。问题来了，这样做岂不是很麻烦？如果我想要我的所有项目都生效的情况下怎么办？我们还有另一个办法，就是将<code>//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</code>添加到<code>~/.npmrc</code>用户目录里面，这样的话，它就属于一个全局变量，在这台电脑上无论是哪一个项目或<code>npm</code>包，都可以使用了。</p>
</blockquote>
<ul>
<li>方式2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm login --registry=https://npm.pkg.github.com</span><br><span class="line">&gt; Username: USERNAME</span><br><span class="line">&gt; Password: TOKEN</span><br><span class="line">&gt; Email: PUBLIC-EMAIL-ADDRESS</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>USERNAME</code>是你的<code>github</code>用户名，<code>Password</code>就是刚才的<code>token</code>，邮箱虽然可以随便填写，为了规范，最好填写你的<code>github</code>邮箱。</p>
</blockquote>
<p>登录成功类似以下输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  npm-repo git:(master) ✗ npm login --registry=https://npm.pkg.github.com</span><br><span class="line">Username: lchenfox</span><br><span class="line">Password:</span><br><span class="line">Email: (this IS public) lchenfox@foxmail.com</span><br><span class="line">Logged in as lchenfox on https://npm.pkg.github.com/.</span><br></pre></td></tr></table></figure>

<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>执行<code>npm publish</code>命令发布</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  npm-repo git:(master) ✗ npm publish</span><br><span class="line">npm notice</span><br><span class="line">npm notice 📦  @lchenfox/npm-repo@1.0.0</span><br><span class="line">npm notice === Tarball Contents ===</span><br><span class="line">npm notice 536B package.json</span><br><span class="line">npm notice 65B  README.md</span><br><span class="line">npm notice === Tarball Details ===</span><br><span class="line">npm notice name:          @lchenfox/npm-repo</span><br><span class="line">npm notice version:       1.0.0</span><br><span class="line">npm notice package size:  437 B</span><br><span class="line">npm notice unpacked size: 601 B</span><br><span class="line">npm notice shasum:        ac8fe26f6cdd65d9bf8f992d56e5f30cc09697ec</span><br><span class="line">npm notice integrity:     sha512-qMlraog/O+uv1[...]GC4/dRBwXgOnA==</span><br><span class="line">npm notice total files:   2</span><br><span class="line">npm notice</span><br><span class="line">+ @lchenfox/npm-repo@1.0.0</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，<code>@lchenfox/npm-repo@1.0.0</code>发布成功，包名是<code>@lchenfox/npm-repo</code>，版本号是<code>1.0.0</code>。</p>
<blockquote>
<p>提示：当使用<code>npm publish</code>发布结束后，一般也会将代码修改同步提供到<code>github</code>仓库，这样的话，<code>npm</code>包和<code>github</code>仓库的内容就一直会保持一致。当然，如果你说我只需要<code>npm</code>包，又不需要管<code>github</code>仓库是什么，那也可以，但是，如果你不提交到<code>github</code>仓库，使其和<code>npm</code>包保持一致的话，那么当你换一台电脑要修改并且发布这个<code>npm</code>包时，就有可能出现版本和内容在两台电脑上都不一样的情况。比如，你在当前电脑发布了一个<code>v1.1.0</code>版本的<code>npm</code>包，在此之前，版本号是<code>v1.0.3</code>，发布<code>v1.1.0</code>之后，你没有提交到<code>github</code>远程仓库，当你在另一台电脑上把仓库克隆下来，<code>package.json</code>版本依然是<code>v1.0.3</code>（因为你的<code>v1.1.0</code>并没有提交），你修改了点内容，然后<code>npm version patch</code>将版本号修改为<code>v1.0.4</code>，然后<code>npm publish</code>发布后，你远程的<code>npm</code>包将以最新的一次发布即<code>v1.0.4</code>的内容为准，那么之前修改的<code>v1.1.0</code>的内容不起任何作用，这样的话，我们就难以保证版本号和内容的统一。因此，强烈建议发布<code>npm</code>包后，立即将改动的代码提交到远程的<code>github</code>仓库。</p>
</blockquote>
<h3 id="查看发布的npm包"><a href="#查看发布的npm包" class="headerlink" title="查看发布的npm包"></a>查看发布的npm包</h3><p><img src="https://i.loli.net/2019/12/26/KE68fdL5spavVe1.png" alt="publish success.png"></p>
<p>点击<code>npm-repo</code>，查看到<code>npm</code>详情</p>
<p><img src="https://i.loli.net/2019/12/26/mZY4KWEaMjzPo1d.png" alt="npm repo.png"></p>
<h3 id="提交代码到远程私有仓库"><a href="#提交代码到远程私有仓库" class="headerlink" title="提交代码到远程私有仓库"></a>提交代码到远程私有仓库</h3><p>为了方便演示，添加一个<code>index.js</code>文件，并添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function printHello() &#123;</span><br><span class="line">	console.warn(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将代码提供到远程私有仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m &quot;init commit&quot; &amp;&amp; git push</span><br></pre></td></tr></table></figure>

<p>远程仓库看起来是这样</p>
<p><img src="https://i.loli.net/2019/12/26/MDIf3ozEx5qj2bi.png" alt="remote repo.png"></p>
<h2 id="使用npm包"><a href="#使用npm包" class="headerlink" title="使用npm包"></a>使用npm包</h2><h3 id="创建-npmrc"><a href="#创建-npmrc" class="headerlink" title="创建.npmrc"></a>创建<code>.npmrc</code></h3><p>这里在项目里面创建<code>.npmrc</code>和上面的<code>.npmrc</code>完全一样，你也可以直接复制到项目中就行。</p>
<p>项目根目录下（<code>node_modules</code>所在的目录），创建<code>.npmrc</code>文件，并添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://npm.pkg.github.com/lchenfox</span><br></pre></td></tr></table></figure>

<h3 id="登录（同创建npm包一样，有2种方式）"><a href="#登录（同创建npm包一样，有2种方式）" class="headerlink" title="登录（同创建npm包一样，有2种方式）"></a>登录（同创建npm包一样，有2种方式）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm login --registry=https://npm.pkg.github.com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在同一台电脑上登录过就不用再登录了。</p>
</blockquote>
<h3 id="安装npm包"><a href="#安装npm包" class="headerlink" title="安装npm包"></a>安装<code>npm</code>包</h3><p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @lchenfox/npm-repo@1.0.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以按照上图中的修改<code>package.json</code>安装。</p>
</blockquote>
<p>安装成功如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  testdemo npm install @lchenfox/npm-repo@1.0.0           </span><br><span class="line">+ @lchenfox/npm-repo@1.0.0</span><br><span class="line">added 1 package from 1 contributor in 9.556s</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/26/KgGMzYVCpkWNEca.png" alt="node-modules.png"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;printHello&#125; from &apos;@lchenfox/npm-repo&apos;;</span><br><span class="line"></span><br><span class="line">printHello(); // Hello</span><br></pre></td></tr></table></figure>

<h2 id="发布多个npm包到同一个私有仓库"><a href="#发布多个npm包到同一个私有仓库" class="headerlink" title="发布多个npm包到同一个私有仓库"></a>发布多个npm包到同一个私有仓库</h2><p>上面我们只讲了如何发布一个<code>npm</code>包到一个私有仓库, 但是有时候，我们想将多个<code>npm</code>包发布到同一个<code>github</code>私有仓库中存放，因为一个<code>npm</code>包创建一个私有仓库简直太<strong>TM</strong>麻烦了，一个私有仓库管理多个<code>npm</code>包在使用上非常方便，也便于管理。</p>
<h3 id="创建npm包-1"><a href="#创建npm包-1" class="headerlink" title="创建npm包"></a>创建npm包</h3><p>首先我们把仓库克隆到本地，比如这里的仓库名是<code>npm-repo</code>，进入到<code>/npm-repo</code>目录下，目前我们只有一个<code>README.md</code>文件，这个是创建<code>github私有仓库</code>的时候初始化的一个文件。然后，我们创建<code>2</code>个文件夹来作为<code>2</code>个<code>npm包</code>的目录，分别为<code>first-package</code>、<code>second-package</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir first-pacakge second-package</span><br></pre></td></tr></table></figure>

<p>进入到<code>first-package</code>里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  first-pacakge git:(master) npm init --scope=lchenfox</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">  1 &#123;</span><br><span class="line">and exactly what they do.</span><br><span class="line">  1 export function printHello1() &#123;</span><br><span class="line"></span><br><span class="line">  1 # Getting started</span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">  1 registry=https://npm.pkg.github.com/lchenfox</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (@lchenfox/first-pacakge)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: first-pacakge</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository: git@github.com:lchenfox/npm-repo.git</span><br><span class="line">keywords: npmdemo</span><br><span class="line">author: langke</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/langke/TestReactNative/github-packages/npm-repo/first-pacakge/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@lchenfox/first-pacakge&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;first-pacakge&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+ssh://git@github.com/lchenfox/npm-repo.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;npmdemo&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/lchenfox/npm-repo/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/lchenfox/npm-repo#readme&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Is this OK? (yes)</span><br></pre></td></tr></table></figure>

<p>上面我选填了<code>description</code>、<code>author</code>、<code>keywords</code>，其实这些项也可以不填，但是必须注意的是 <code>git repository: git@github.com:lchenfox/npm-repo.git</code> 是必填项，<code>git@github.com:lchenfox/npm-repo.git</code>是你的<code>github私有仓库</code>地址。如果你忘记填写<code>git repository</code>，也没有关系，可以初始化结束后编辑<code>pacage.json</code>文件，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;repository&quot; : &#123;</span><br><span class="line">    &quot;type&quot; : &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;ssh://git@github.com/lchenfox/npm-repo.git&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其中，<code>type</code>就是<code>git</code>,  <code>url</code>就是私有仓库地址，其中，<code>lchenfox</code>是<code>github</code>用户名， <code>npm-repo</code>是私有仓库名。</p>
<p>然后按照上面的步骤依次添加<code>publishConfig</code>到<code>pacage.json</code>、创建<code>.npmrc</code>文件、登录，另外为了方便演示，分别在<br><code>first-package</code>、<code>second-package</code>创建<code>README.md</code>和<code>index.js</code>文件。</p>
<p>最终，<code>first-package</code>共有<code>4</code>个文件：<code>.npmrc</code>、<code>README.md</code>、<code>index.js</code>、<code>package.json</code>，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  first-pacakge git:(master) ✗ l</span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x  6 langke  staff   192B Dec 27 09:32 .</span><br><span class="line">drwxr-xr-x  6 langke  staff   192B Dec 27 09:22 ..</span><br><span class="line">-rw-r--r--  1 langke  staff    45B Dec 27 09:32 .npmrc</span><br><span class="line">-rw-r--r--  1 langke  staff    33B Dec 27 09:32 README.md</span><br><span class="line">-rw-r--r--  1 langke  staff    59B Dec 27 09:32 index.js</span><br><span class="line">-rw-r--r--  1 langke  staff   581B Dec 27 09:31 package.json</span><br><span class="line"></span><br><span class="line">➜  first-pacakge git:(master) ✗ cat .npmrc</span><br><span class="line">registry=https://npm.pkg.github.com/lchenfox</span><br><span class="line"></span><br><span class="line">➜  first-pacakge git:(master) ✗ cat README.md</span><br><span class="line"># Getting started</span><br><span class="line"></span><br><span class="line">first package</span><br><span class="line"></span><br><span class="line">➜  first-pacakge git:(master) ✗ cat index.js</span><br><span class="line">export function printHello1() &#123;</span><br><span class="line">	console.warn(&quot;hello1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜  first-pacakge git:(master) ✗ cat package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@lchenfox/first-pacakge&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;first-pacakge&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;registry&quot;:&quot;https://npm.pkg.github.com/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+ssh://git@github.com/lchenfox/npm-repo.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;npmdemo&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/lchenfox/npm-repo/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/lchenfox/npm-repo#readme&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>second-package</code>内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  second-package git:(master) ✗ l</span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x  6 langke  staff   192B Dec 27 10:05 .</span><br><span class="line">drwxr-xr-x  6 langke  staff   192B Dec 27 09:22 ..</span><br><span class="line">-rw-r--r--  1 langke  staff    45B Dec 27 10:05 .npmrc</span><br><span class="line">-rw-r--r--  1 langke  staff    34B Dec 27 09:54 README.md</span><br><span class="line">-rw-r--r--  1 langke  staff    59B Dec 27 09:54 index.js</span><br><span class="line">-rw-r--r--  1 langke  staff   583B Dec 27 09:54 package.json</span><br><span class="line"></span><br><span class="line">➜  second-package git:(master) ✗ cat .npmrc</span><br><span class="line">registry=https://npm.pkg.github.com/lchenfox</span><br><span class="line"></span><br><span class="line">➜  second-package git:(master) ✗ cat README.md</span><br><span class="line"># Getting started</span><br><span class="line"></span><br><span class="line">second package</span><br><span class="line"></span><br><span class="line">➜  second-package git:(master) ✗ cat index.js</span><br><span class="line">export function printHello2() &#123;</span><br><span class="line">	console.warn(&quot;hello2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜  second-package git:(master) ✗ cat package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@lchenfox/second-pacakge&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;second-pacakge&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;registry&quot;:&quot;https://npm.pkg.github.com/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+ssh://git@github.com/lchenfox/npm-repo.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;npmdemo&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/lchenfox/npm-repo/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/lchenfox/npm-repo#readme&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外一般会添加一个<code>.gitignore</code>文件用于忽略掉如<code>.idea</code>、<code>.DS_Store</code>文件，还会添加一个<code>CHANGELOG.md</code>文件用于描述每一个版本的变更，这样才更方便<code>npm</code>使用者。</p>
</blockquote>
<p>然后执行<code>npm publish</code>发布到<code>GitHub Packages</code>， 如图</p>
<p><img src="https://i.loli.net/2019/12/27/RGM3LIpBzlvDgP7.png" alt="mul-packages.png"></p>
<p>可以看到，两个<code>npm包</code>分别为<code>first-package</code>、<code>second-package</code>，都发布到了<code>GitHub Packages</code>，并且都放到同一个仓库（<code>npm-repo</code>）当中，最后别忘记了将代码提交到远程的私有仓库中。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>和上面的使用是一样的，我们来安装一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @lchenfox/first-pacakge@1.0.0</span><br><span class="line">npm install @lchenfox/second-pacakge@1.0.0</span><br></pre></td></tr></table></figure>

<p>安装成功后，在项目的<code>node_modules</code>里面看起来如下</p>
<p><img src="https://i.loli.net/2019/12/27/xjsqrG6ocCmJeFp.png" alt="multiple-packages.png"></p>
<p>导入使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;printHello1&#125; from &apos;@lchenfox/first-pacakge&apos;;</span><br><span class="line">import &#123;printHello2&#125; from &apos;@lchenfox/second-pacakge&apos;;</span><br><span class="line"></span><br><span class="line">printHello1(); // hello1</span><br><span class="line">printHello2(); // hello2</span><br></pre></td></tr></table></figure>

<p>到此，我们就知道如何使用<code>GitHub Packages</code>来创建<code>npm</code>私有库了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>必须注意</strong>：本文所有<code>lchenfox</code>一定是你自己的<code>github</code>用户名，所有<code>_authToken</code>一定是你自己的<code>Personal access tokens</code>。</p>
<h3 id="发布npm包必须满足两个条件"><a href="#发布npm包必须满足两个条件" class="headerlink" title="发布npm包必须满足两个条件"></a>发布npm包必须满足两个条件</h3><ul>
<li>第<code>1</code>点，要么创建<code>.npmrc</code>文件，里面添加<code>registry=https://npm.pkg.github.com/lchenfox</code>，要么就直接在<code>package.json</code>中添加<code>publishConfig</code></li>
<li>第<code>2</code>点，要么在<code>.npmrc</code>（如果没有就创建一个）文件中添加<code>//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</code>授权，要么使用<code>npm login --registry=https://npm.pkg.github.com</code>登录授权</li>
</ul>
<h3 id="安装npm包必须满足两个条件"><a href="#安装npm包必须满足两个条件" class="headerlink" title="安装npm包必须满足两个条件"></a>安装npm包必须满足两个条件</h3><ul>
<li>第<code>1</code>点，必须在项目根目录下（<code>node_modules</code>所在目录）创建<code>.npmrc</code>并且添加<code>registry=https://npm.pkg.github.com/lchenfox</code></li>
<li>第<code>2</code>点，同以上发布npm包的第<code>2</code>点</li>
</ul>
<p>使用<code>GitHub Packages</code>来创建和托管<code>npm</code>包非常方便，我们可以使用<code>npm</code>的相关命令，发布、安装方式基本和<code>npm</code>一样，使用这种方式来创建属于我们自己的私有库，维护起来也很简单，和之前的几种方式比起来，我个人觉得这种方式很适合搭建(或许只能说创建？)公司内部的<code>npm</code>私有库。</p>
<p>注意：虽然我们使用了<code>.npmrc</code>文件，但是，不要把<code>//npm.pkg.github.com/:_authToken=0fc31c688a4a75f9509444b4648ac8e5fbeb20c4</code>提供到<code>github</code>仓库，因为<code>GitHub</code>官方为了安全考虑，不允许提交到仓库，如果你提交了，<code>GitHub</code>会自动检测，并且撤销这个<code>token</code>，那么你下次安装、发布都没用了，只能重新生成<code>token</code>!!! 你可以添加在<code>.gitignore</code>文件里面添加忽略<code>.npmrc</code>文件就好了，也就是说<code>.npmrc</code>文件只能放在本地！</p>
<p>更多详情，比如如何在一个项目从多个<code>GitHub</code>账号拉取多个不同来源的<code>npm</code>依赖包，请查看官方：<a href="https://help.github.com/en/github/managing-packages-with-github-packages/configuring-npm-for-use-with-github-packages#installing-packages-from-other-organizations" target="_blank" rel="noopener">Installing packages from other organizations</a>、<a href="https://help.github.com/en/github/managing-packages-with-github-packages" target="_blank" rel="noopener">Managing packages with GitHub Packages</a>。</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>npm</tag>
        <tag>私有仓库</tag>
        <tag>npm私有库</tag>
        <tag>GitHub Packages</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github实现npm私有库的搭建</title>
    <url>/2019/12/23/%E5%9F%BA%E4%BA%8Egithub%E5%AE%9E%E7%8E%B0npm%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在上一篇文章<a href="https://www.clcoder.com/2019/12/20/verdaccio%20+%20ngrok%E5%8F%91%E5%B8%83npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">verdaccio+ngrok发布npm私有仓库</a>中，我们介绍了如何使用<code>verdaccio + ngrok</code>来搭建我们的<code>npm</code>私有库，虽然基本实现了我们想要的效果，但是那种方式并不一定是最好的，也未必被一部分人接受，毕竟其一些缺陷还是有些麻烦，难以管理。今天，我们将介绍另一种搭建<code>npm私有库</code>的方式：<code>npm + github</code>来实现搭建<code>npm私有库</code>。</p>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><h4 id="在github上创建一个私有仓库，如下图"><a href="#在github上创建一个私有仓库，如下图" class="headerlink" title="在github上创建一个私有仓库，如下图"></a>在<code>github</code>上创建一个私有仓库，如下图</h4><p><img src="https://i.loli.net/2019/12/23/4sAjfh18EuTdgxe.png" alt="private_repo.png"></p>
<h4 id="克隆github仓库到本地"><a href="#克隆github仓库到本地" class="headerlink" title="克隆github仓库到本地"></a>克隆<code>github</code>仓库到本地</h4><p><img src="https://i.loli.net/2019/12/23/V23ozIhFWsrNS6x.png" alt="git clone.png"></p>
<h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><p>进入到刚才克隆下来的仓库目录，这里演示的路径是<code>/Users/langke/TestReactNative/github-npm-dir/rn-npm-demo</code>，其中<code>/Users/langke/TestReactNative/github-npm-dir</code>是我本地文件夹路径，你可以随便选一个自己的路径即可，<code>/rn-npm-demo</code>就是克隆下来的仓库。使用<code>npm init --scope=公司名</code>来初始化仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  rn-npm-demo git:(master) ✗ npm init --scope=mycompany</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (@mycompany/rn-npm-demo)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: A private npm package demo</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository: (https://github.com/lchenfox/rn-npm-demo.git)</span><br><span class="line">keywords:</span><br><span class="line">author: langke</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/langke/TestReactNative/github-npm-dir/rn-npm-demo/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@mycompany/rn-npm-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A private npm package demo&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https://github.com/lchenfox/rn-npm-demo.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/lchenfox/rn-npm-demo/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/lchenfox/rn-npm-demo#readme&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this OK? (yes) yes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在<code>npm init --scope=公司名</code>来初始化仓库的过程中，你只需要填写<code>description</code>和<code>author</code>项，甚至这两项都是可选的，其他的信息你不需要填写直接一路回车就好。<code>name</code>也就是我们的<code>npm</code>包名，当使用<code>npm init --scope=公司名</code>来初始化时，默认的生成的包名是<code>@公司名/githun上的仓库名称</code>，比如上面我填写的公司名是<code>mycompany</code>，<code>rn-npm-demo</code>是<code>github</code>上面的仓库名，所以最终创建的默认的<code>npm</code>包名就是<code>@mycompany/rn-npm-demo</code>。如果你填写了其他的名称，那么最终的包名将不再是<code>@mycompany/rn-npm-demo</code>，而是你填了什么，就是什么！不过，不建议填写这一项，因为我们使用<code>npm init --scope=公司名</code>的目的就是为了使用<code>公司名</code>来区分我们自己创建的私有库和其他的<code>npm</code>库，比如我一看到导入的是带有<code>@mycompany</code>的<code>npm</code>包，那么我一看就知道这是公司自己写的私有库，如果重新填写了<code>name</code>项，那使用<code>npm init --scope=公司名</code>就没有多大意义了。</p>
</blockquote>
<h4 id="创建index-js文件"><a href="#创建index-js文件" class="headerlink" title="创建index.js文件"></a>创建<code>index.js</code>文件</h4><p>创建<code>index.js</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi index.js</span><br></pre></td></tr></table></figure>

<p>并添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.putMsg = function() &#123;</span><br><span class="line">	console.warn(&quot;Great! you got a private npm package on github!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>ls</code>命令来查看当前仓库所有的文件，应该如下<code>4</code>个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  rn-npm-demo git:(master) ✗ ls</span><br><span class="line">LICENSE      README.md    index.js     package.json</span><br></pre></td></tr></table></figure>

<h4 id="提交到远程"><a href="#提交到远程" class="headerlink" title="提交到远程"></a>提交到远程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  rn-npm-demo git:(master) ✗ git add . &amp;&amp; git commit -m &quot;init commit&quot; &amp;&amp; git push</span><br><span class="line">[master 6dd0afa] init commit</span><br><span class="line"> 2 files changed, 22 insertions(+)</span><br><span class="line"> create mode 100644 index.js</span><br><span class="line"> create mode 100644 package.json</span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (4/4), 686 bytes | 686.00 KiB/s, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:lchenfox/rn-npm-demo.git</span><br><span class="line">   9cbf75a..6dd0afa  master -&gt; master</span><br></pre></td></tr></table></figure>

<h2 id="安装方式-npm-vs-yarn"><a href="#安装方式-npm-vs-yarn" class="headerlink" title="安装方式 npm vs yarn"></a>安装方式 npm vs yarn</h2><h4 id="使用npm"><a href="#使用npm" class="headerlink" title="使用npm"></a>使用npm</h4><ul>
<li>不需要添加<code>ssh key</code>（任何人都可以安装）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install git+https://github.com/lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install lchenfox/rn-npm-demo</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install github:lchenfox/rn-npm-demo</span><br></pre></td></tr></table></figure>

<ul>
<li>必须添加<code>ssh key</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install git+ssh://git@github.com:lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<ul>
<li>安装具体的版本</li>
</ul>
<p>如果需要安装具体的版本，必须要打<code>tag</code>，每一个<code>tag</code>就代表一个版本，因此建议是每一次修改都要增加<code>tag版本号</code>。比如已经有一个打好的<code>tag</code>版本为<code>2.0</code>，要安装具体<code>2.0</code>版本，可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/lchenfox/private_demo.git#2.0</span><br></pre></td></tr></table></figure>


<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install git+https://github.com/lchenfox/private_demo.git#2.0</span><br></pre></td></tr></table></figure>

<h4 id="使用yarn"><a href="#使用yarn" class="headerlink" title="使用yarn"></a>使用yarn</h4><ul>
<li>不需要添加<code>ssh key</code>（任何人都可以安装）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add https://github.com/lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add git+https://github.com/lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<ul>
<li>必须添加<code>ssh key</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add lchenfox/rn-npm-demo</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add github:lchenfox/rn-npm-demo</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add git+ssh://git@github.com:lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<h4 id="针对以上必须添加ssh-key的命令使用权限时，如何处理呢？"><a href="#针对以上必须添加ssh-key的命令使用权限时，如何处理呢？" class="headerlink" title="针对以上必须添加ssh key的命令使用权限时，如何处理呢？"></a>针对以上<strong>必须添加<code>ssh key</code>的命令</strong>使用权限时，如何处理呢？</h4><p>第一种方式是直接将电脑上的<code>ssh key（公钥）</code>添加到<code>github</code>私有仓库所有者，这样你就可以访问所有仓库（包含私有仓库）的权限，如下：</p>
<p><img src="https://i.loli.net/2019/12/23/rBLmD2jpiCPGOqw.png" alt="sshkey.png"></p>
<p>另一种方式是直接将电脑上的<code>ssh key（公钥）</code>添加到<code>github</code>的私有仓库，这样你仅仅只能够访问这个私有仓库，如下（推荐，为了安全，限制权限）：</p>
<p><img src="https://i.loli.net/2019/12/23/UnFskeNHtG6OBvr.png" alt="ssh-key.png"></p>
<blockquote>
<p>事实上，还有第三种方式，如上图，在私有仓库里面还有一个<code>Collaborators</code>，你可以为这个仓库添加团队成员，这样又分2种情况，第一种情况：如果被添加的成员使用<code>CLI（命令行模式）</code>，那么他也要将他自己电脑上的<code>ssh key</code>添加到他自己的<code>github</code>的<code>SSH and GPG keys</code>中（上面的第一种方式）；第二种情况：被添加的成员不喜欢使用<code>CLI（命令行模式）</code>，而是使用<code>IDE（比如WebStorm）</code>登录他自己的<code>github</code>账号来执行<code>pull</code>、<code>push</code>、<code>npm install</code>等等操作，那么<strong>他就没有必要将他自己电脑上的<code>ssh key</code>添加到他自己的<code>github</code>的<code>SSH and GPG keys</code>中</strong>。这听起来似乎很别扭，但是事实就是如此，因为他直接使用他自己的账号访问自己仓库并没有任何问题，但是使用<code>CLI</code>模式的话，就跟他是否登录<code>github</code>没有关系了。简单来说就是，只要使用<code>CLI</code>模式，不管是被添加的成员还是仓库持有者，都必须添加<code>ssh key</code>。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>和正常使用<code>npm install</code>一样，不同的是后面跟的不是具体的包名，而是一个<code>github</code>上的<code>https</code>链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/lchenfox/rn-npm-demo.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次安装可能会有点慢，我这里用了大概<code>3</code>分钟时间才安装成功。</p>
</blockquote>
<p>查看一下<code>package.json</code>文件，我们可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  testnpm cat package.json</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@mycompany/rn-npm-demo&quot;: &quot;git+https://github.com/lchenfox/rn-npm-demo.git&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;16.8.3&quot;,</span><br><span class="line">    &quot;react-native&quot;: &quot;0.59.9&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/23/jbiN5sLc3r1mgtd.png" alt="success.png"></p>
<p>可以看到<code>@mycompany/rn-npm-demo</code>这个我们自己的<code>npm</code>私有库已经安装成功。</p>
<blockquote>
<p>提示：使用<code>npm install https://github.com/lchenfox/rn-npm-demo.git</code>和<code>yarn add https://github.com/lchenfox/rn-npm-demo.git</code>生成的在<code>node_modules</code>中的依赖<code>package.json</code>（也就是<code>node_modules/@mycompany/rn-npm-demo/package.json</code>）内容是不一样的，<code>npm install</code>会自动给你配置一些其他路径或参数，用<code>yarn add</code>的方式生成的方式看起来比较正常，虽然都不影响正常安装使用，但是我个人更推荐使用<code>yarn</code>工具来安装依赖，在速度、效率上都比<code>npm</code>要好，当然，这取决于你的喜好！</p>
</blockquote>
<p>现在，在你的项目中导入使用试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;putMsg&#125; from &apos;@mycompany/rn-npm-demo&apos;;</span><br><span class="line"></span><br><span class="line">putMsg(); // Great! you got a private npm package on github!</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文，我们基本了解了如何以<code>npm + github</code>的形式来搭建<code>npm</code>私有库，但是同样地，它也有着优缺点。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>基于<code>github</code>私有库来搭建<code>npm</code>私有库，搭建简单</li>
<li>管理方便，只需要维护<code>github</code>私有库，不需要本地搭建服务器、数据库等</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在<code>package.json</code>设置<code>private</code>为<code>true</code>(为了保证不小心发布到<code>npm</code>官方库）</li>
<li>安装之后，想要更新，只能重新<code>npm install xxx</code></li>
<li>发布的时候不能使用<code>npm</code>的相关命令，比如<code>npm version patch</code>、<code>npm publish</code></li>
<li>有时候拉取都比较慢，有时容易失败</li>
</ul>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>npm</tag>
        <tag>私有仓库</tag>
        <tag>npm-github</tag>
      </tags>
  </entry>
  <entry>
    <title>verdaccio+ngrok发布npm私有仓库</title>
    <url>/2019/12/20/verdaccio%20+%20ngrok%E5%8F%91%E5%B8%83npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在上一篇(<a href="https://www.clcoder.com/2019/12/18/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E5%88%B0npm%E5%AE%98%E6%96%B9%E4%BB%93%E5%BA%93/#more" target="_blank" rel="noopener">如何发布代码到npm官方仓库</a>)文章中，我们介绍了如何将自己的代码发布到<code>npm</code>官方仓库，通过那种方式，我们可以将自己写的任何组件开源给别人用，和我们日常在<code>github</code>上使用的三方库是一个道理。我们也说过，我们发布的组件或包都是开源的，任何人都可以访问并且可以在<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm官方仓库</a>搜索到的，虽然<code>npm</code>官方提供的收费版也可以发布私有仓库，特别方便，但是，太<code>TM</code>贵了！所以，今天我们来继续介绍另一种不使用<code>npm官方提供的收费版私有仓库</code>的方式，来搭建属于我们自己的仅仅公司内部可使用的<code>npm</code>私有仓库 – <code>verdaccio &amp; ngrok</code>。</p>
<h4 id="verdaccio"><a href="#verdaccio" class="headerlink" title="verdaccio"></a>verdaccio</h4><p>一个轻量级的<a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">私有npm代理注册表</a>，你可以将<code>verdaccio</code>理解为一个<strong>私有npm仓库服务器</strong>，因为使用<code>verdaccio</code>，你可以将<code>npm</code>包发布到你的本地仓库，此时你自己的电脑就是一台<code>npm</code>私有仓库服务器，你可以在你的电脑发布<code>npm</code>包，并且通过<code>npm install</code>来安装使用。</p>
<h4 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h4><p><a href="https://ngrok.com/" target="_blank" rel="noopener">ngrok</a>就是一个<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">方向代理</a>，这里的主要作用是实现<a href="https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" target="_blank" rel="noopener">内网穿透</a>，因为使用<code>verdaccio</code>搭建本地私有<code>npm</code>仓库服务器后，你的电脑就是作为服务器使用，你可以在你的电脑上下载（<code>npm install</code>）、使用你发布的私有<code>npm</code>仓库，但是另一台电脑或服务器上是不能访问的，也就是除了你，其他任何人都没法使用你发布的<code>npm</code>私有仓库，如果你想要别人也能够使用你发布的<code>npm</code>私有仓库的话，你必须将类似由<code>verdaccio</code>服务生成的类似<code>http://localhost:4873</code>的<code>url</code>暴露给他人，通过<code>ngrok</code>你可以将你自己电脑上的本地<code>url</code>映射到大千世界，以至于别人能够通过映射的<code>新url</code>访问你的<code>npm</code>私有仓库。</p>
<h2 id="搭建npm私有本地仓库"><a href="#搭建npm私有本地仓库" class="headerlink" title="搭建npm私有本地仓库"></a>搭建npm私有本地仓库</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先要全局安装<code>verdaccio</code>，使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global verdaccio</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以使用简写<code>npm install -g verdaccio</code>，两者并没区别。</p>
</blockquote>
<p>安装成功后，接着启动<code>verdaccio</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">verdaccio</span><br></pre></td></tr></table></figure>

<p>启动之后，你应该就能看到</p>
<p><img src="https://i.loli.net/2019/12/20/U8CBgPXKbti9d6x.png" alt="verdaccio.png"></p>
<p>图中的<code>http://localhost:4873</code>就是启动后的本地服务的<code>url</code>，在浏览器中打开它，你应该能够看到</p>
<p><img src="https://i.loli.net/2019/12/20/5zcIlg2ZHdS3raQ.png" alt="verdaccio url.png"></p>
<p>内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No Package Published Yet.</span><br><span class="line">To publish your first package just:</span><br><span class="line">1. Login</span><br><span class="line">npm adduser --registry http://localhost:4873</span><br><span class="line"></span><br><span class="line">2. Publish</span><br><span class="line">npm publish --registry http://localhost:4873</span><br><span class="line"></span><br><span class="line">3. Refresh this page.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：虽然这里登陆&amp;发布都在后缀添加了<code>--registry http://localhost:4873</code>，也就是为了指定发布在本地服务<code>http://localhost:4873</code>上，这样也是为了误操作发布到官方<code>npm</code>仓库。但是为了后面不添加后缀就可以和正常的<code>npm</code>操作一样，不用添加任何后缀，我们会直接更新<code>npm</code>默认源，见下面👇<code>更新默认npm源</code>。</p>
</blockquote>
<h3 id="更新默认npm源"><a href="#更新默认npm源" class="headerlink" title="更新默认npm源"></a>更新默认npm源</h3><p>设置<code>http://localhost:4873</code>为<code>npm</code>默认源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http://localhost:4873</span><br></pre></td></tr></table></figure>

<p>为什么要设置<code>http://localhost:4873</code>为<code>npm</code>默认源？</p>
<p>首先要清楚的是，我们电脑上<code>npm</code>的镜像源是官方的<code>http://registry.npmjs.org/</code>，因此当我们使用<code>npm publish</code>或者<code>npm install</code>的时候，都是发布或安装到<code>npm</code>官方仓库，如果这样的话，使用<code>verdaccio</code>还有什么意义？我们还怎么发布私有库？所以我们要本地发布、安装<code>npm</code>私有仓库，就必须要使用<code>verdaccio</code>的镜像源，也就是刚才的本地<code>url</code> <strong>–</strong> <code>http://localhost:4873</code>，我们可以使用下面的命令查看当前的镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<p>更新默认<code>npm</code>镜像源后，你应该看到能够看到输出的镜像源是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ npm config get registry</span><br><span class="line">http://localhost:4873/</span><br></pre></td></tr></table></figure>

<h3 id="创建私有npm用户"><a href="#创建私有npm用户" class="headerlink" title="创建私有npm用户"></a>创建私有npm用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这里使用<code>npm adduser</code>（你也可以使用<code>npm login</code>）之后会要求你输入<code>用户名</code>、<code>密码</code>、<code>邮箱</code>三个信息，然后会创建一个<code>npm本地账户</code>，为什么说是<code>npm本地账户</code>？因为这个账号的镜像源是<code>http://localhost:4873</code>而不是官方的<code>http://registry.npmjs.org/</code>，因此如果你使用这个<code>npm本地账户</code>到官方网站登录的话，你会发现你无法登录，换句话说，这个账号属于本地所有，不被官方<code>npm</code>所承认，两者是不同的<code>npm</code>账号。</p>
</blockquote>
<h2 id="创建本地私有npm包"><a href="#创建本地私有npm包" class="headerlink" title="创建本地私有npm包"></a>创建本地私有npm包</h2><p>创建<code>npm</code>包和我们官方的<code>npm</code>创建发布到<code>npm</code>官方仓库的命令基本一样，如果你还不熟悉发布公有仓库到<code>npm</code>官方仓库，建议还是先看一下<a href="https://www.clcoder.com/2019/12/18/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E5%88%B0npm%E5%AE%98%E6%96%B9%E4%BB%93%E5%BA%93/#more" target="_blank" rel="noopener">如何发布代码到npm官方仓库</a></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在你想要创建<code>npm</code>私有仓库的文件夹目录下，我的是<code>/Users/langke/TestReactNative/verdaccio-dir</code>，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>填写相应信息，我的输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (verdaccio-dir) first-verdaccio-npm-demo</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: This is the first private npm demo for verdaccio.</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords: verdaccio-npm-demo</span><br><span class="line">author: langke</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/langke/TestReactNative/verdaccio-dir/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;first-verdaccio-npm-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is the first private npm demo for verdaccio.&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;verdaccio-npm-demo&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this OK? (yes) yes</span><br></pre></td></tr></table></figure>

<p>创建一个<code>index.js</code>和<code>README.md</code>文件，并添加内容（这一步非必须，我这里只是掩饰）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  verdaccio-dir vi index.js</span><br><span class="line">➜  verdaccio-dir ls</span><br><span class="line">index.js     package.json</span><br><span class="line">➜  verdaccio-dir vi README.md</span><br><span class="line">➜  verdaccio-dir cat README.md</span><br><span class="line"># Getting started</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p><code>package.json</code>文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;first-verdaccio-npm-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is the first private npm demo for verdaccio.&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;verdaccio-npm-demo&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;langke&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布本地npm包"><a href="#发布本地npm包" class="headerlink" title="发布本地npm包"></a>发布本地npm包</h2><p>再次提醒，这里发布的<code>npm</code>包只在自己的电脑上，也就是本地的<code>http://localhost:4873（这是我们刚才用来替换npm官方的registry源）</code>，发布的是一个在本地私有服务器上的一个私有<code>npm</code>包。此时，只有自己能够查看、下载、安装，别人没有任何权限的。</p>
<p>发布命令和正常<code>npm</code>命令一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<p>输出类似如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm notice</span><br><span class="line">npm notice 📦  first-verdaccio-npm-demo@1.0.0</span><br><span class="line">npm notice === Tarball Contents ===</span><br><span class="line">npm notice 91B  index.js</span><br><span class="line">npm notice 321B package.json</span><br><span class="line">npm notice 33B  README.md</span><br><span class="line">npm notice === Tarball Details ===</span><br><span class="line">npm notice name:          first-verdaccio-npm-demo</span><br><span class="line">npm notice version:       1.0.0</span><br><span class="line">npm notice package size:  455 B</span><br><span class="line">npm notice unpacked size: 445 B</span><br><span class="line">npm notice shasum:        df639fd12218accfa1949cb933e496ddea020078</span><br><span class="line">npm notice integrity:     sha512-N4TmHO2xcNSL9[...]SINM/KD+TR5EA==</span><br><span class="line">npm notice total files:   3</span><br><span class="line">npm notice</span><br><span class="line">+ first-verdaccio-npm-demo@1.0.0</span><br></pre></td></tr></table></figure>

<p>到这里，说明本地的<code>npm</code>私有库发布成功！</p>
<p>在刚才打开<code>http://localhost:4873</code>的页面上，刷新页面，可以看到</p>
<p><img src="https://i.loli.net/2019/12/20/SGtie3qgHLvf5nu.png" alt="npm publish.png"></p>
<p>看到了没，这个<code>first-verdaccio-npm-demo</code>就是我们刚刚发布的<code>npm</code>私有库，现在自己就可以像正常使用<code>npm</code>官方的命令那样安装到本地依赖使用了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>找到你的项目（最好是测试项目），安装试试(我使用的是<code>yarn</code>，你也可以使用<code>npm</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add first-verdaccio-npm-demo</span><br></pre></td></tr></table></figure>

<p>然后出现类似下面输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add v1.17.3</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">[2/4] 🚚  Fetching packages...</span><br><span class="line">[3/4] 🔗  Linking dependencies...</span><br><span class="line">warning &quot;@react-native-community/eslint-config &gt; @typescript-eslint/eslint-plugin@1.13.0&quot; has incorrect peer dependency &quot;eslint@^5.0.0&quot;.</span><br><span class="line">warning &quot;@react-native-community/eslint-config &gt; @typescript-eslint/parser@1.13.0&quot; has incorrect peer dependency &quot;eslint@^5.0.0&quot;.</span><br><span class="line">warning &quot;@react-native-community/eslint-config &gt; eslint-plugin-react@7.12.4&quot; has incorrect peer dependency &quot;eslint@^3.0.0 || ^4.0.0 || ^5.0.0&quot;.</span><br><span class="line">warning &quot;@react-native-community/eslint-config &gt; eslint-plugin-react-native@3.6.0&quot; has incorrect peer dependency &quot;eslint@^3.17.0 || ^4 || ^5&quot;.</span><br><span class="line">warning &quot;@react-native-community/eslint-config &gt; @typescript-eslint/eslint-plugin &gt; tsutils@3.17.1&quot; has unmet peer dependency &quot;typescript@&gt;=2.8.0 || &gt;= 3.2.0-dev || &gt;= 3.3.0-dev || &gt;= 3.4.0-dev || &gt;= 3.5.0-dev || &gt;= 3.6.0-dev || &gt;= 3.6.0-beta || &gt;= 3.7.0-dev || &gt;= 3.7.0-beta&quot;.</span><br><span class="line">[4/4] 🔨  Building fresh packages...</span><br><span class="line">success Saved lockfile.</span><br><span class="line">success Saved 1 new dependency.</span><br><span class="line">info Direct dependencies</span><br><span class="line">└─ first-verdaccio-npm-demo@1.0.0</span><br><span class="line">info All dependencies</span><br><span class="line">└─ first-verdaccio-npm-demo@1.0.0</span><br><span class="line">✨  Done in 2.73s.</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/20/FO8SRPxKa3yXdtM.png" alt="yarn add.png"></p>
<p>太棒了，在<code>package.json</code>中的<code>dependencies</code>依赖中终于成功安装我们的<code>npm</code>私有库<code>first-verdaccio-npm-demo</code>了，继续看下<code>node_modules</code>中</p>
<p><img src="https://i.loli.net/2019/12/20/XNHfdu1MDsSKgWm.png" alt="node_modules.png"></p>
<p>现在，尽情地在你的项目中使用这个组件吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;putMsg&#125; from &apos;first-verdaccio-npm-demo&apos;;</span><br><span class="line"></span><br><span class="line">putMsg(); // Great, you got a private npm repository!</span><br></pre></td></tr></table></figure>

<p>但是，这样还不够啊！只有我自己可以使用，那别人（比如公司内部的团队成员）要怎么才能安装我的这个私有库呢？是时候祭出我们的尚方宝剑<code>ngrok</code>了。</p>
<h2 id="使用ngrok让本地npm私有库公有化"><a href="#使用ngrok让本地npm私有库公有化" class="headerlink" title="使用ngrok让本地npm私有库公有化"></a>使用ngrok让本地npm私有库公有化</h2><h4 id="安装ngrok"><a href="#安装ngrok" class="headerlink" title="安装ngrok"></a>安装ngrok</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i ngrok -g</span><br></pre></td></tr></table></figure>

<h4 id="暴露4873端口"><a href="#暴露4873端口" class="headerlink" title="暴露4873端口"></a>暴露4873端口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngrok http 4873</span><br></pre></td></tr></table></figure>

<p>输出类似如下</p>
<p><img src="https://i.loli.net/2019/12/20/DZ5vGkVdRqtFzLb.png" alt="ngrok.png"></p>
<p>在上图中我们可以看到<code>http://8f76570f.ngrok.io -&gt; http://localhost:4873（当然还有https）</code>，其中<code>http://8f76570f.ngrok.io</code>就是我们通过<code>ngrok</code>反向代理将本地<code>http://localhost:4873</code>公开给外部环境，这样，别人也可以访问你刚才发布的<code>npm</code>私有库<code>first-verdaccio-npm-demo</code>。你可以在另一台电脑上访问<code>http://8f76570f.ngrok.io</code>，它和我们刚才在自己电脑上访问<code>http://localhost:4873</code>是一样的，并且能够看到刚刚发布的私有库。</p>
<h4 id="使用私有库"><a href="#使用私有库" class="headerlink" title="使用私有库"></a>使用私有库</h4><p>现在，别人能够访问我们刚才发布的私有库了，但是，要想使用刚才发布的私有库还需要在相应电脑上设置<code>npm</code>镜像源为<code>http://8f76570f.ngrok.io</code>，因为默认的是官方的<code>http://registry.npmjs.org/</code>，这很好理解。</p>
<p>在要访问当前电脑上的<code>npm</code>私有库，在另一台电脑上更新<code>npm</code>镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http://8f76570f.ngrok.io</span><br></pre></td></tr></table></figure>

<p>然后安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install first-verdaccio-npm-demo</span><br></pre></td></tr></table></figure>

<p>这样，就能够实现除了在本电脑的服务上使用<code>npm</code>私有库外，团队成员也能够使用相应私有库了。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>虽然使用 <code>verdaccio + ngrok</code> 来部署<code>npm</code>私有库，但是也有一些缺点。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>实现npm私有库发布，不对外公开（除非你把代理源比如<code>http://8f76570f.ngrok.io</code>给外部人员），也可以在<code>~/.config/verdaccio/config.yaml</code>添加访问权限，默认<code>access: $all</code>，这样最保险（<code>verdaccio</code>的具体配置，自己去官方网站看即可）</li>
</ul>
<p>这里还是顺便提一下<code>access</code>字段，如果你设置为<code>access: $authenticated</code>，意味着你在网页打开也必须要登录才能查看、安装（也就是我们上面说的<code>npm adduser</code>创建的账户），如果你已经在<code>terminal</code>上登录，并且在执行<code>npm install</code>的时候还是报错类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add v1.17.3</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">error An unexpected error occurred: &quot;http://localhost:4873/first-verdaccio-npm-demo: </span><br><span class="line">authorization required to access package first-verdaccio-npm-demo&quot;.</span><br><span class="line">info If you think this is a bug, please open a bug report with the information </span><br><span class="line">provided in &quot;/Users/langke/TestReactNative/fuckmap/yarn-error.log&quot;.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/add for documentation about this command.</span><br></pre></td></tr></table></figure>

<p>那么请执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set always-auth=true</span><br></pre></td></tr></table></figure>

<p>这样的话，你只要登录你的账号（无论是浏览器还是终端），就能查看/下载了。重要的是，如果你用<code>npm adduser（或npm login）</code>创建了多个账号，比如<code>test1/test123、test2/test234</code>，那么在授权的时候，你可以登录其中任意一个的账号都可以访问和下载（因为你注册的多个账号都在你本机的<code>verdaccio</code>服务上）。</p>
<ul>
<li><p>可以使用和官方<code>npm</code>一样的命令，比如<code>npm version patch</code></p>
</li>
<li><p>操作、配置简单，基本无难度</p>
</li>
<li><p>verdaccio本身自带小型数据库，可缓存已经<code>npm install</code>过的私有库（如果网络不好或获取不到本台电脑上的私有库的话，会从缓存中获取）</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>可能会经常要切换<code>npm</code>代理源，因为有时候你可能会使用官方仓库，就得切换官方或其他代理源，再用私有库的时候又得切换回来（团队成员要安装已更新的<code>npm</code>包一样要设置）</p>
</li>
<li><p><code>verdaccio</code>服务和<code>ngrok</code>服务要保持开着，一旦断开，任何人（包括本机）都无法安装和发布，只能重新启动<code>verdaccio</code>和<code>ngrok</code>服务，对方如果想要更新最新发布的私有库版本，也要重新设置<code>ngrok</code>产生的类似<code>http://8f76570f.ngrok.io</code>的镜像源（本机如果设置<code>npm config set registry http://localhost:4873</code>就不用，因为<code>http://localhost:4873</code>是不变的，变的只是映射出去的<code>http://8f76570f.ngrok.io</code>）</p>
</li>
<li><p>ngrok服务器在国外，有时会比较慢</p>
</li>
<li><p>ngrok代理的镜像源比如<code>http://8f76570f.ngrok.io</code>没有固定<code>url</code>，每一次执行<code>ngrok http 4873</code>，都会改变。因此如果在新电脑或者其他人设置过<code>http://8f76570f.ngrok.io</code>作为镜像源，在本机上再次执行<code>ngrok http 4873</code>后，对方也要跟着重新设置类似的<code>npm config set registry http://8f76570f.ngrok.io</code>操作，这显然很麻烦（因为使用的是免费版，收费版可以代理固定的<code>url</code>，但如果那样的话，那为何不使用<code>npm</code>官方提供的收费版呢？）</p>
</li>
<li><p><code>http://8f76570f.ngrok.io</code>在每分钟内访问有限制，访问太快，浏览器会报如下错误(恢复也较快，30秒左右，可自己尝试)：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Too Many Connections</span><br><span class="line">Too many connections! The tunnel session &apos;1VF8JMx9QsgS6GcWS9gPBZyQQO4&apos; has violated </span><br><span class="line">the rate-limit policy of 20 connections per minute by initiating 37 connections in </span><br><span class="line">the last 60 seconds. Please decrease your inbound connection volume or upgrade to </span><br><span class="line">a paid plan for additional capacity.</span><br><span class="line"></span><br><span class="line">The error encountered was: ERR_NGROK_702</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>verdaccio + ngrok</code>配置起来比较方便，也能迎合<code>npm</code>的相关命令，安装和操作都特别简单，<code>verdaccio</code>也提供本地缓存，这个很棒。但是速度这一块以及<code>ngrok</code>产生的代理源不固定，团队协作安装较为麻烦，这个有时候真的不能忍受（可以看上面的优缺点）。但是，如果能接受的话，这也不失为一个选择。如果你有比<code>ngrok</code>更好用的反代理或者其他工具，请告诉我。下一章我会介绍<a href="http://www.clcoder.com/2019/12/23/%E5%9F%BA%E4%BA%8Egithub%E5%AE%9E%E7%8E%B0npm%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/#more" target="_blank" rel="noopener">基于github实现npm私有库的搭建</a>。</p>
<p>参考文章：<a href="https://medium.com/strapi/testing-your-npm-package-before-releasing-it-using-verdaccio-ngrok-28e2832c850a" target="_blank" rel="noopener">Testing your npm package before releasing it using Verdaccio + ngrok</a></p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>npm</tag>
        <tag>私有仓库</tag>
        <tag>verdaccio-ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>【RN】如何发布代码到npm官方仓库</title>
    <url>/2019/12/18/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E5%88%B0npm%E5%AE%98%E6%96%B9%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候我们想把自己的组件像在<code>github</code>上提供的以<code>npm</code>方式安装到本地的方式给别人用，我们就可以到<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm官方网站</a>注册自己的账号并以<code>CLI</code>的形式将自己的代码发布到<code>npm官方仓库</code>。</p>
<p>但是，目前来说，我们可以发布到<code>npm官方仓库</code>的组件或库都是<strong>公开的</strong>，这意味着是开源的，也就是<strong>任何人都可以搜索到你发布的这个仓库并且安装使用</strong>。</p>
<p>官方目前提供<code>2</code>种方式，一种是免费的，也就是我们刚才说的公开的，这种方式不会限制你发布多少包到<code>npm</code>，你发布十个、百个甚至上千个都行，只要你开心，想发就发；另一种方式是收费的，具体的价格<a href="https://www.npmjs.com/products" target="_blank" rel="noopener">npm官方价格说明</a>，当然，这种收费的好处是，我们可以发布<strong>私有仓库</strong>，这种<strong>私有仓库</strong>别人未经授权是看不到摸不着。如果你只是想把自己的组件开源给别人用，发扬开源精神，那么使用免费的就可以了，如果你不想提供给别人用，比如说是公司内部的一些业务组件、功能组件等，那么除了<code>npm</code>官方收费的方式以外，也有一些其他创建<strong>私有npm仓库</strong>的方式。但是在这篇文章中，只讲发布<strong>免费版</strong>的仓库。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>首先第一件事就是注册，<strong>你必须拥有一个npm账号才能发布包</strong>，这是一个必须的步骤。</p>
<ul>
<li>1.<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm官方网站</a>，点击<code>Sign Up</code></li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/ZhRYnaHIl1MNcG3.png" alt="Sign Up.png"></p>
<ul>
<li>2.填写注册信息，然后点击<code>Create an Account</code></li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/Vwar9YP3XB5OGy4.png" alt="Sign Up.png"></p>
<ul>
<li>3.登录邮箱，将类似红框中的链接复制到你的浏览器中，回车，验证完毕</li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/4KdZJtUsyYQmqXA.png" alt="Verify Email.png"></p>
<ul>
<li>4.注册成功，你将看到如下界面</li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/R5H94eqfsn3J1Uh.png" alt="Success.png"></p>
<h2 id="创建-amp-发布包"><a href="#创建-amp-发布包" class="headerlink" title="创建&amp;发布包"></a>创建&amp;发布包</h2><ul>
<li>1.打开<code>terminal</code>，随便找一个文件夹作为测试仓库，执行<code>npm adduser</code></li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/TDpUZVaYlxEArmb.png" alt="init.png"></p>
<blockquote>
<p>图中的<code>langke_npm</code>是我自己随便创建的文件夹，你也可以自己随意命名创建，开心就好。另外，你也可以使用<code>npm login</code>来代替命令<code>npm adduser</code>，两者并没有什么区别，如果不信，那就看这里<a href="https://docs.npmjs.com/cli/adduser.html" target="_blank" rel="noopener">见识一下官方npm login &amp; npm adduser</a>。然后，输入用户名、密码、邮箱，注意，输入密码的时候你是看不见的，这是<code>terminal</code>为了保护你的安全，做了隐藏，出现类似<code>Logged in as langke007 on http://registry.npmjs.org/.</code>，你已经登录成功。</p>
</blockquote>
<ul>
<li>2.初始化仓库，执行<code>npm init</code></li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/LEk45XIV8bUORMA.gif" alt="npm init.gif"></p>
<blockquote>
<p>执行<code>npm init</code>后，会填写一些相应信息，根据提示填写即可，没什么难度，结束后会生成一个<code>package.json</code>文件，里面就包含你填写的所有信息。</p>
</blockquote>
<ul>
<li>3.创建<code>README.md</code>、<code>index.js</code>文件</li>
</ul>
<p><img src="https://i.loli.net/2019/12/18/nEWZzSJy3u9Hq6V.png" alt="instruction.png"></p>
<ul>
<li>4.发布，执行<code>npm publish</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  langke_npm npm publish</span><br><span class="line">npm notice</span><br><span class="line">npm notice 📦  langke_npm_demo@1.0.0</span><br><span class="line">npm notice === Tarball Contents ===</span><br><span class="line">npm notice 60B  index.js</span><br><span class="line">npm notice 292B package.json</span><br><span class="line">npm notice 33B  README.md</span><br><span class="line">npm notice === Tarball Details ===</span><br><span class="line">npm notice name:          langke_npm_demo</span><br><span class="line">npm notice version:       1.0.0</span><br><span class="line">npm notice package size:  410 B</span><br><span class="line">npm notice unpacked size: 385 B</span><br><span class="line">npm notice shasum:        730c17ff5fd22e05d0a1e05088b74066667c292d</span><br><span class="line">npm notice integrity:     sha512-+80RanxwwDwTv[...]ZJDWYN+EDm37w==</span><br><span class="line">npm notice total files:   3</span><br><span class="line">npm notice</span><br><span class="line">+ langke_npm_demo@1.0.0</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/12/18/6HcM3zBEU5DCPIk.gif" alt="npm publish.gif"></p>
<blockquote>
<p>进入到网页，你就可以看到刚才所发布的包，具体见上图。如果发布遇到类似<code>npm ERR! no_perms Private mode enable, only admin can publish this module</code>的错误，应该是镜像源的问题，使用官方镜像源，执行<code>npm config set registry http://registry.npmjs.org</code>。</p>
</blockquote>
<h2 id="使用刚才发布的包"><a href="#使用刚才发布的包" class="headerlink" title="使用刚才发布的包"></a>使用刚才发布的包</h2><p>我这里是<code>React Native</code>项目，但是都是一样的道理，到根目录下执行</p>
<ul>
<li>1.安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install langke_npm_demo</span><br></pre></td></tr></table></figure>

<p>然后在项目中的文件里导入</p>
<ul>
<li>2.使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;printHello&#125; from &apos;langke_npm_demo&apos;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printHello()</span><br></pre></td></tr></table></figure>

<h2 id="取消发布"><a href="#取消发布" class="headerlink" title="取消发布"></a>取消发布</h2><p>使用命令<code>npm unpublish &lt;package-name&gt; -f</code>来取消发布，这样的话，你刚才发布的包就会被撤回，等于没有发布！</p>
<p><img src="https://i.loli.net/2019/12/18/nP2IotwfBvAJESK.gif" alt="npm unpublish.gif"></p>
<h2 id="在新电脑或者新目录下更新并发布已有的npm包"><a href="#在新电脑或者新目录下更新并发布已有的npm包" class="headerlink" title="在新电脑或者新目录下更新并发布已有的npm包"></a>在新电脑或者新目录下更新并发布已有的npm包</h2><p>如果你换了一台新电脑，或者删除了刚才所创建的<code>npm</code>包，那么可以在新电脑或者新目录下，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;package-name&gt;</span><br></pre></td></tr></table></figure>

<p>安装结束后，你会看到一个<code>node_modules</code>文件夹，里面有你刚才创建的<code>npm</code>包，然后一切都和前面的发布一样，修改任意你想修改的文件，在有<code>package.json</code>文件的目录下，执行<code>npm publish</code>就可以了。但是要记住，每一次发布<code>npm</code>包都需要修改版本号，否则你将发布失败！具体修改版本号后面也有常用的配套命令介绍，往下看，没兴趣的话，就到此为止。</p>
<h2 id="关联github"><a href="#关联github" class="headerlink" title="关联github"></a>关联github</h2><p>有时候我们看到别人发布到<code>npm</code>官方仓库的包，具有如下红框中的部分，也就是关联到<code>github</code>，包括<code>Issues</code>、<code>Pull Requests</code>等等</p>
<p><img src="https://i.loli.net/2019/12/18/zvshy1cAudSNgfJ.png" alt="sample.png"></p>
<p>为了让我们的公共仓库也能关联到<code>github</code>，我们可以在创建<code>npm</code>包的时候填写<code>git repository</code>一栏填写<code>github</code>的某个仓库的<code>https</code>地址，如下</p>
<p><img src="https://i.loli.net/2019/12/18/iqIJEYM1fSTalsQ.gif" alt="npm github.gif"></p>
<blockquote>
<p>这里我已经提前在<code>github</code>上创建了一个<code>langke-npm-demo1</code>的仓库了，所以关联地址的时候，之后复制过去就好了。</p>
</blockquote>
<h2 id="一些常用npm命令介绍"><a href="#一些常用npm命令介绍" class="headerlink" title="一些常用npm命令介绍"></a>一些常用npm命令介绍</h2><ul>
<li>查看当前登录的npm用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm whoami</span><br></pre></td></tr></table></figure>

<ul>
<li>查看npm配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前使用的npm镜像源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<ul>
<li>切换npm镜像源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry 【这里是镜像源url】</span><br></pre></td></tr></table></figure>

<h3 id="npm修改版本号"><a href="#npm修改版本号" class="headerlink" title="npm修改版本号"></a>npm修改版本号</h3><p>比如要将版本号从<code>1.0.0</code>修改为<code>2.0.0</code>，有<code>2</code>种方式</p>
<h4 id="一-手动修改"><a href="#一-手动修改" class="headerlink" title="一 手动修改"></a>一 手动修改</h4><p>直接修改<code>package.json</code>文件中的版本号</p>
<p>原来的<code>package.json</code>内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;react-native-demo-for-npm&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;this is just a npm demo&quot;,</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;react-native-demo-for-npm&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;this is just a npm demo&quot;,</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二-命令修改"><a href="#二-命令修改" class="headerlink" title="二 命令修改"></a>二 命令修改</h4><ul>
<li>1.修改指定版本号</li>
</ul>
<p>在有<code>package.json</code>的当前目录下，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version 新版本号</span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version 2.0.0</span><br></pre></td></tr></table></figure>

<p>这样的话，在发布之前，就可以将版本号从<code>1.0.0</code>修改为<code>2.0.0</code>了。</p>
<ul>
<li>2.由npm命令生成有序版本号</li>
</ul>
<p>2.1) 修改主版本号，如果当前版本号是<code>1.0.0</code>，要修改为<code>2.0.0</code>，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version major</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式一般用于包的大幅度改动，如增加了大量了<code>API</code>或者发生其他大量的内容修改。</p>
</blockquote>
<p>2.2) 修改次版本号，比如当前版本号是<code>1.0.0</code>，要修改为<code>1.1.0</code>，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version minor</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式一般用于包的小幅度改动，比如增加了一些<code>API</code>的前后兼容，扩展等等。</p>
</blockquote>
<p>2.3）修改补丁版本号，比如当前版本号是<code>1.0.0</code>，要修改为<code>1.0.1</code>，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm version patch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方式一般用于打补丁，也就是一些<code>bug</code>修复，没有做其他太大的内容变化。</p>
</blockquote>
<ul>
<li>查看已发布的npm包所有版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm view react-native-demo-for-npm versions</span><br></pre></td></tr></table></figure>

<h3 id="撤销已经发布的包"><a href="#撤销已经发布的包" class="headerlink" title="撤销已经发布的包"></a>撤销已经发布的包</h3><ul>
<li>一 撤销整个包</li>
</ul>
<p>1.1）如果已经将<code>npm</code>包发布到远程<code>npm</code>仓库，但是又想撤销发布</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish &lt;package-name&gt; -f</span><br></pre></td></tr></table></figure>

<p>比如，已经发布到<code>npm</code>仓库的包名叫做<code>react-native-demo</code>，那么运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish react-native-demo -f</span><br></pre></td></tr></table></figure>

<p>则<code>react-native-demo</code>就从<code>npm</code>仓库上删除了，你也无法再从<code>npm</code>仓库搜索到这个包。</p>
<p>1.2）如果开启了<code>2FA(two-factor authentication)</code>，那么就需要在<code>publish</code>后面加上<code>--otp=123456</code>，这里的<code>123456</code>是手机上<code>app（app名称叫做 Authenticator）</code>获取的授权码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish --otp=123456 react-native-demo -f</span><br></pre></td></tr></table></figure>

<ul>
<li>二 撤销具体的版本</li>
</ul>
<p>2.1）如果想要撤销已经发布的具体版本，则可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish &lt;package-name&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>比如，现在有<code>2</code>个版本，分别是<code>v1.0.0</code>、<code>v1.2.0</code>，想要撤销<code>v1.2.0</code>，可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish react-native-demo@1.2.0</span><br></pre></td></tr></table></figure>

<p>2.2）同样地，如果开启了<code>2FA(two-factor authentication)</code>，那么就需要在<code>publish</code>后面加上<code>--otp=123456</code>，这里的<code>123456</code>是手机上<code>app（app名称叫做 Authenticator）</code>获取的授权码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm unpublish react-native-demo@1.2.0 --otp=123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：撤销整个包或具体的版本只有在从开始发布内的<code>72</code>小时内有效，具体见 <a href="https://docs.npmjs.com/unpublishing-packages-from-the-registry" target="_blank" rel="noopener">官网：Unpublishing packages from the registry</a></p>
</blockquote>
<p>下一篇文章将介绍 <a href="http://www.clcoder.com/2019/12/20/verdaccio%20+%20ngrok%E5%8F%91%E5%B8%83npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/#more" target="_blank" rel="noopener">verdaccio+ngrok发布npm私有仓库</a></p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>npm</tag>
        <tag>私有仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>RN之[pod install] Error installing DoubleConversion</title>
    <url>/2019/12/13/pod%20install-Error%20installing%20DoubleConversion/</url>
    <content><![CDATA[<h2 id="为什么要写这篇文章？"><a href="#为什么要写这篇文章？" class="headerlink" title="为什么要写这篇文章？"></a>为什么要写这篇文章？</h2><p>在<code>RN</code>工程中，当我们使用<code>cocoapods</code>来安装一些<code>RN</code>必须的第三方编译库（比如<code>Folly</code>、<code>boost</code>），由于这些编译库是在国外，并且无论翻墙与否，很多时候直接使用<code>cocoapods</code>来自动下载安装基本都会失败，最近尝试在原来的<code>RN</code>工程和新建的<code>RN</code>工程上面都做了尝试，结果尝试了<code>3</code>天，基本都是失败的，报错的原因都是一样，这样的话，项目根本没法运行。因此，在这种自动安装经常失败甚至一直失败的情况下，了解手动下载安装就必不可少了。</p>
<h4 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ios pod install</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `DoubleConversion` from `../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec`</span><br><span class="line">Fetching podspec for `Folly` from `../node_modules/react-native/third-party-podspecs/Folly.podspec`</span><br><span class="line">Fetching podspec for `glog` from `../node_modules/react-native/third-party-podspecs/glog.podspec`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing DoubleConversion (1.1.6)</span><br><span class="line"></span><br><span class="line">[!] Error installing DoubleConversion</span><br><span class="line">[!] /usr/local/bin/git clone https://github.com/google/double-conversion.git /var/folders/mn/7jdnkyy91_n0bxkrgjgjk17c0000gn/T/d20191212-36568-33nxni --template= --single-branch --depth 1 --branch v1.1.6</span><br><span class="line"></span><br><span class="line">Cloning into &apos;/var/folders/mn/7jdnkyy91_n0bxkrgjgjk17c0000gn/T/d20191212-36568-33nxni&apos;...</span><br><span class="line">error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: unpack-objects failed</span><br></pre></td></tr></table></figure>

<h4 id="报错原因："><a href="#报错原因：" class="headerlink" title="报错原因："></a>报错原因：</h4><p><code>RPC(Remote Procedure Call)</code>连接失败，基本可以判定是由于网络原因，这种可能性很多，代理、局域网等等，尤其是针对国外的一些资源，对于国内的开发者来说，很不友好。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info Fetching system and libraries information...</span><br><span class="line">System:</span><br><span class="line">    OS: macOS Mojave 10.14.5</span><br><span class="line">    CPU: (4) x64 Intel(R) Core(TM) i3-8100B CPU @ 3.60GHz</span><br><span class="line">    Memory: 221.88 MB / 8.00 GB</span><br><span class="line">    Shell: 5.3 - /bin/zsh</span><br><span class="line">  Binaries:</span><br><span class="line">    Node: 12.10.0 - /usr/local/bin/node</span><br><span class="line">    Yarn: 1.17.3 - ~/.yarn/bin/yarn</span><br><span class="line">    npm: 6.11.3 - /usr/local/bin/npm</span><br><span class="line">    Watchman: 4.9.0 - /usr/local/bin/watchman</span><br><span class="line">  SDKs:</span><br><span class="line">    iOS SDK:</span><br><span class="line">      Platforms: iOS 12.2, macOS 10.14, tvOS 12.2, watchOS 5.2</span><br><span class="line">    Android SDK:</span><br><span class="line">      API Levels: 23, 26, 27, 28</span><br><span class="line">      Build Tools: 23.0.1, 26.0.1, 27.0.3, 28.0.2, 28.0.3</span><br><span class="line">      System Images: android-23 | Intel x86 Atom_64, android-23 | Google APIs Intel x86 Atom, android-23 | Google APIs Intel x86 Atom_64, android-26 | Google APIs Intel x86 Atom, android-27 | Intel x86 Atom_64, android-27 | Google APIs Intel x86 Atom, android-27 | Google Play Intel x86 Atom, android-28 | Google Play Intel x86 Atom</span><br><span class="line">  IDEs:</span><br><span class="line">    Android Studio: 3.5 AI-191.8026.42.35.5977832</span><br><span class="line">    Xcode: 10.2.1/10E1001 - /usr/bin/xcodebuild</span><br><span class="line">  npmPackages:</span><br><span class="line">    react: 16.9.0 =&gt; 16.9.0</span><br><span class="line">    react-native: 0.61.5 =&gt; 0.61.5</span><br><span class="line">  npmGlobalPackages:</span><br><span class="line">    react-native-cli: 2.0.1</span><br><span class="line">    react-native-update-cli: 0.1.0</span><br></pre></td></tr></table></figure>

<h2 id="重现"><a href="#重现" class="headerlink" title="重现"></a>重现</h2><p>我们就基于现有的环境新建一个项目来重现这个<code>RPC</code>错误。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>使用<code>CLI</code>新建一个<code>RN</code>项目，运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react-native init demo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里，我使用的是默认新建最新版本，目前<code>RN</code>的最新版本是 <code>0.61.5</code>，你也可以使用<code>react-native init 工程名 --version 版本</code>指定某一个具体的<code>RN</code>版本，比如要创建一个<code>0.59.9</code>的版本，可以使用<code>react-native init demo --version 0.59.9</code>。</p>
</blockquote>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>进入到该<code>/demo/ios</code>目录下，运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在<code>RN</code>版本大于<code>0.6</code>的情况下，<code>iOS</code>工程默认使用<code>cocoapods</code>来集成项目环境，因此，在运行项目之前，必须先使用<code>cocoapods</code>安装所需依赖，因此要运行<code>pod install</code>命令。对于<code>0.6</code>以下的<code>RN</code>项目，也可以进入到<code>/ios</code>目录下运行<code>pod init</code>生成一个<code>Podfile</code>文件，在<code>Podfile</code>文件里面添加依赖，然后运行<code>pod install</code>安装依赖，原理是一样的。</p>
</blockquote>
<h4 id="错误产生❌"><a href="#错误产生❌" class="headerlink" title="错误产生❌"></a>错误产生❌</h4><p>在运行<code>pod install</code>后，等待了大概十几分钟（特别慢），报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ios pod install</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec for `DoubleConversion` from `../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec`</span><br><span class="line">Fetching podspec for `Folly` from `../node_modules/react-native/third-party-podspecs/Folly.podspec`</span><br><span class="line">Fetching podspec for `glog` from `../node_modules/react-native/third-party-podspecs/glog.podspec`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing DoubleConversion (1.1.6)</span><br><span class="line"></span><br><span class="line">[!] Error installing DoubleConversion</span><br><span class="line">[!] /usr/local/bin/git clone https://github.com/google/double-conversion.git /var/folders/mn/7jdnkyy91_n0bxkrgjgjk17c0000gn/T/d20191212-36568-33nxni --template= --single-branch --depth 1 --branch v1.1.6</span><br><span class="line"></span><br><span class="line">Cloning into &apos;/var/folders/mn/7jdnkyy91_n0bxkrgjgjk17c0000gn/T/d20191212-36568-33nxni&apos;...</span><br><span class="line">error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: unpack-objects failed</span><br></pre></td></tr></table></figure>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>为了能够尽可能安装成功，在自动安装失败的情况下，我们采用手动安装来解决这个问题。</p>
<p>首先，进入<a href="https://github.com/facebook/react-native/blob/master/scripts/ios-install-third-party.sh" target="_blank" rel="noopener">Github: react-native官网的目录react-native/scripts/ios-install-third-party.sh下</a>，你将能够看到：</p>
<p><img src="https://i.loli.net/2019/12/13/sqOlS5ENi4oAxtZ.png" alt="shot.png"></p>
<blockquote>
<p>注意：左边的<code>Branch</code>选择是对应你当前是所用的<code>RN</code>版本，比如你使用的是<code>0.61.5</code>，那对应的就是上图中的<code>0.61-stable</code>，如果你使用的是<code>0.59.9</code>，那对应的就是<code>0.59-stable</code>。但是，一般情况下，有部分连续的版本的<code>ios-install-third-party.sh</code>对应的编译库是一样的，这个可以自己去查看。为了保险起见，尽量保持和你当前所使用的<code>RN</code>版本一致。</p>
</blockquote>
<p>进入到<code>ios-install-third-party.sh</code>文件后，滑到最底部，你将会看到如下图所示：</p>
<p><img src="https://i.loli.net/2019/12/13/74QEHstVo6krmKx.png" alt="shot.png"></p>
<blockquote>
<p>注意：我们可以看到有<code>4</code>个对应的编译库文件就是相应的<code>RN</code>版本所需要的编译库，这<code>4</code>个编译库都需要你下载。</p>
</blockquote>
<p>接下来，我们有<code>2</code>种方式来下载<code>4</code>个编译库对应的压缩包：</p>
<ul>
<li>第一种方式</li>
</ul>
<p><a href="https://pan.baidu.com/s/1kVDUAZ9#list/path=%2F" target="_blank" rel="noopener">依赖库下载链接：RN中文网作者的第三方依赖库百度网盘链接</a></p>
<ul>
<li>第二种方式</li>
</ul>
<p>如果在<code>第一种方式</code>中没有找到对应的依赖库版本（有可能随着版本更新，<code>RN</code>中文网的作者没来得及更新或者忘记了），那么你可以用另一种稍微麻烦一点但是<code>100%</code>正确的方式来下载你所需要的依赖库，继续往下看</p>
<p>在上面的图片中，我们看到了<code>4</code>个依赖库以及对应的链接，是的，没错，我们可以通过对应的链接找到相应的压缩包版本，然后下载。这里以第一个<code>glog-0.3.5.tar.gz</code>为例，它对应所在的<code>github</code>链接地址是：<code>https://github.com/google/glog</code>（后面的一串串不需要，我们只需要它所在的<code>github</code>地址），打开之后如下：</p>
<p><img src="https://i.loli.net/2019/12/13/oaRvN3xygQY1TAl.png" alt="shot.png"></p>
<p>点击上图中的<code>releases</code>，进入可以找到相应版本如下：</p>
<p><img src="https://i.loli.net/2019/12/13/Zs9IC3dUPno6TRG.png" alt="shot.png"></p>
<p>然后点击红圈中的<code>Source code(tar.gz)</code>下载，完成。（其他<code>3</code>个依赖库类似）</p>
<p>下载完<code>4</code>个依赖压缩包之后，不用解压，我们直接放到相应的目录当中：</p>
<ul>
<li><code>RN</code>版本在<code>&gt;=0.58</code></li>
</ul>
<p>将压缩包放到 <code>~/Library/Caches/com.facebook.ReactNativeBuild</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ cd ~/Library/Caches/com.facebook.ReactNativeBuild</span><br><span class="line">➜  com.facebook.ReactNativeBuild pwd</span><br><span class="line">/Users/langke/Library/Caches/com.facebook.ReactNativeBuild</span><br><span class="line">➜  com.facebook.ReactNativeBuild ls</span><br><span class="line">boost_1_63_0.tar.gz  double-conversion-1.1.6.tar.gz folly-2018.10.22.00.tar.gz  glog-0.3.5.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：或许在<code>~/Library/Caches</code>目录下，你并没有<code>com.facebook.ReactNativeBuild</code>文件夹，怎么办？进入到<code>cd ~/Library/Caches</code>目录下，然后使用<code>mkdir com.facebook.ReactNativeBuild</code>创建一个就好了。</p>
</blockquote>
<ul>
<li><code>RN</code>版本在<code>&lt;0.58</code></li>
</ul>
<p>将压缩包放到 <code>~/.rncache</code>目录下，一般情况下<code>.rncache</code>文件夹也是有的，如果没有，同理，使用 <code>mkdir .rncache</code>创建一个就好。</p>
<blockquote>
<p>注意：虽然我们可以使用环境变量的方式自定义路径，但是我个人还是建议按照正常的这种全局方式去配置比较好，毕竟，自定义路径很可能因为个人疏忽而出错，这个也因人而异，如果想要使用具体环境变量自定义路径，可前往：<a href="https://www.reactnative.cn/topic/4301/ios-rn-0-45%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E6%89%80%E9%9C%80%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BC%96%E8%AF%91%E5%BA%93-boost%E7%AD%89" target="_blank" rel="noopener">RN中文网作者的指导说明</a>，本文也主要来源于此的参考。</p>
</blockquote>
<h2 id="完毕"><a href="#完毕" class="headerlink" title="完毕"></a>完毕</h2><p>运行 <code>pod install</code>: </p>
<p><img src="https://i.loli.net/2019/12/13/JyQdX1U8mTx5CiV.png" alt="shot.png"></p>
<p>经过上面的一番小折腾，到此为止，基本告一段落，也应该可以稍微正常<code>pod install</code>了。还是会有点慢，甚至也有可能会失败，但是多尝试几次应该会成功。</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>pod install</tag>
        <tag>编译库</tag>
        <tag>DoubleConversion</tag>
        <tag>Folly</tag>
        <tag>glog</tag>
        <tag>Error installing DoubleConversion</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC底层原理</title>
    <url>/2019/11/21/KVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>KVC(Key-Value-Coding)</code>即<code>键值编码</code>，在<code>iOS</code>中应用及其广泛，我们通常使用<code>KVC</code>来<em>设置值</em>和<em>获取值</em>，知道<code>KVC</code>的基本运作原理对我们在日常开发中修复<code>bug</code>起到很好的作用。</p>
<h2 id="KVC之取值"><a href="#KVC之取值" class="headerlink" title="KVC之取值"></a>KVC之取值</h2><h4 id="valueForKey"><a href="#valueForKey" class="headerlink" title="valueForKey"></a>valueForKey</h4><p>首先，来看一个简单问题，创建一个<code>Person</code>类。</p>
<p><code>Person.h</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>Person.m</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在<code>ViewController.m</code>中，导入<code>Person.h</code>，<code>ViewController.m</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	[self test];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">	Person *p = [[Person alloc] init];</span><br><span class="line">	// 注意，获取的时候这个key必须是成员变量的原形！！！</span><br><span class="line">	// 比如，如果这里不是name, 而是下划线 _name 那么就要就Person类</span><br><span class="line">	// 里面的成员变量一定要有_name，否则就会奔溃！</span><br><span class="line">	NSString *name = [p valueForKey:@&quot;name&quot;];</span><br><span class="line">	NSLog(@&quot;name is %@&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在运行之前，先思考一下结果是什么？</p>
<p>答案是：<strong>程序崩溃，抛出异常！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &apos;NSUnknownKeyException&apos;, </span><br><span class="line">reason: &apos;[&lt;Person 0x600002c35340&gt; valueForUndefinedKey:]: this class </span><br><span class="line">is not key value coding-compliant for the key name.&apos;</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？我们来分析一下：<code>实例对象p</code>并没有这个<code>name</code>成员变量或者说没有这个属性，在调用<code>KVC</code>的<code>valueForKey</code>方法时，由于找不到<code>name</code>从而执行了<code>- (id)valueForUndefinedKey:(NSString *)key</code>这个方法，接着就抛出了异常，因此程序崩溃。</p>
<p>不信，我们来验证一下，在<code>Person.h</code>中，复写<code>- (id)valueForUndefinedKey:(NSString *)key</code>方法，于是<code>Person.m</code>的内容就变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key &#123;</span><br><span class="line">	return @&quot;hello, world!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>再次运行，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is hello, world!</span><br></pre></td></tr></table></figure>

<p>哇，果然如此！当使用<code>valueForKey</code>方法时，如果查找不到相应的属性或成员变量，就直接走<code>valueForUndefinedKey</code>抛出异常。</p>
<p>问题是，<code>KVC</code>是如何查找属性或成员变量的呢？我们来继续验证：</p>
<p>在<code>Person.h</code>中，定义<code>name</code>成员变量，并在<code>Person.m</code>的初始化方法中给<code>name</code>赋值。</p>
<p>于是，<code>Person.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	NSString *name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>Person.m</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">	self = [super init];</span><br><span class="line">	if (self) &#123;</span><br><span class="line">		name = @&quot;name&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>运行程序，结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is name</span><br></pre></td></tr></table></figure>

<p>一点也不意外，按正常的逻辑执行，我们再添加一个<code>_name</code>成员变量并赋值</p>
<p><code>Person.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	NSString *name;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>Person.m</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">	self = [super init];</span><br><span class="line">	if (self) &#123;</span><br><span class="line">		_name = @&quot;_name&quot;;</span><br><span class="line">		name = @&quot;name&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>运行程序，结果是什么呢？</p>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is _name</span><br></pre></td></tr></table></figure>

<p>到这里，我们可以确定<strong><code>_name</code>的优先级比<code>name</code>的优先级要高。</strong></p>
<p>同理，我们可以添加成员变量<code>_isName</code>和<code>isName</code>，同上面比较的方法一样比较（这里就不继续演示了），可以发现成员变量的查找优先级如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_name &gt; _isName &gt; name &gt; isName</span><br></pre></td></tr></table></figure>

<p>也就是说，<strong>在<code>KVC</code>中，查找成员变量或属性的方式是，首先查找<code>_key</code>，如果找不到，继续查找<code>_isKey</code>，再找不到，继续查找<code>key</code>，还是查找不到，才查找<code>isKey</code>，如果<code>isKey</code>都找不到的话，程序将抛出异常（除非你重写了<code>- (id)valueForUndefinedKey:(NSString *)key</code>方法）。</strong></p>
<hr>
<p>我们知道，在<code>Objective-C</code>中，有一个东西叫<code>属性</code>，而<code>属性</code>的本质就是对<code>成员变量</code>、<code>setter</code>、<code>getter</code>方法的封装，那么当我们通过<code>KVC</code>调用<code>valueForKey</code>方法获取实例变量的时候，而获取的方式很类似<code>getter</code>，因为<code>getter</code>就表示获取的意思，那么，它与<code>getter</code>方法有什么关系呢？</p>
<p><code>Person.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	NSString *isName;</span><br><span class="line">	NSString *_isName;</span><br><span class="line">	NSString *name;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>Person.m</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">	self = [super init];</span><br><span class="line">	if (self) &#123;</span><br><span class="line">		_isName = @&quot;init~_isName&quot;;</span><br><span class="line">		_name = @&quot;init~_name&quot;;</span><br><span class="line">		name = @&quot;init~name&quot;;</span><br><span class="line">		isName = @&quot;init~isName&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)getName</span><br><span class="line">&#123;</span><br><span class="line">	return @&quot;getName&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">	return @&quot;name&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)isName</span><br><span class="line">&#123;</span><br><span class="line">	return @&quot;isName&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)_getName</span><br><span class="line">&#123;</span><br><span class="line">	return @&quot;_getName&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)_name</span><br><span class="line">&#123;</span><br><span class="line">	return @&quot;_name&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>运行程序，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is getName</span><br></pre></td></tr></table></figure>

<p>很明显，当通过<code>valueForKey</code>获取<code>name</code>成员变量，若有<code>- (NSString *)getName</code>方法存在，则优先执行这个方法，并且不再去获取实例变量在<code>- (instancetype)init</code>的初始化值。另外值得注意的是，执行了<code>- (NSString *)getName</code>方法，说明其优先级大于<code>- (NSString *)name</code>、<code>- (NSString *)isName</code>、<code>- (NSString *)_getName</code>、<code>- (NSString *)_name</code>方法。</p>
<p>我们去掉<code>- (NSString *)getName</code>方法，再次运行，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is name</span><br></pre></td></tr></table></figure>

<p>接着去掉<code>- (NSString *)name</code>方法，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is isName</span><br></pre></td></tr></table></figure>

<p>接着去掉<code>- (NSString *)isName</code>方法，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is _getName</span><br></pre></td></tr></table></figure>

<p>接着去掉<code>- (NSString *)_getName</code>方法，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is _name</span><br></pre></td></tr></table></figure>

<p>结果表明，只要<code>- (NSString *)getName</code>、<code>- (NSString *)name</code>、<code>- (NSString *)isName</code>、<code>- (NSString *)_getName</code>、<code>- (NSString *)_name</code>中的任何一个方法存在，就不再去获取初始化中的<code>name</code>成员变量的值。</p>
<p>也就是说，在<code>KVC</code>中，只要存在<code>- (NSString *)getKey</code>、<code>- (NSString *)key</code>、<code>- (NSString *)isKey</code>、<code>- (NSString *)_getKey</code>、<code>- (NSString *)_key</code>方法，其优先级都比成员变量高，其中优先级顺序是：<code>- (NSString *)getKey</code> &gt; <code>- (NSString *)key</code> &gt; <code>- (NSString *)isKey</code> &gt; <code>- (NSString *)_getKey</code> &gt; <code>- (NSString *)_key</code>。</p>
<blockquote>
<p>事实上，<code>- (NSString *)getKey</code> &gt; <code>- (NSString *)key</code>、<code>- (NSString *)isKey</code>、<code>- (NSString *)_getKey</code> 、 <code>- (NSString *)_key</code>在底层本质上都是<code>getter</code>方法，就如同查找成员变量一样，<code>Apple</code>提供了多种获取方式。</p>
</blockquote>
<p>还有一点要特别注意，当没有以上的<code>相关方法</code>时，我们知道<code>valueForKey</code>会去查找实例变量的值，但是，在查找实例变量之前，其实还执行了一个方法，它是<code>+ (BOOL)accessInstanceVariablesDirectly</code>并且其默认返回值为<code>YES</code>，如果既没有上面的<code>gettter</code>方法，并且<code>+ (BOOL)accessInstanceVariablesDirectly</code>的返回值为<code>NO</code>，那么将会直接走<code>- (id)valueForUndefinedKey:(NSString *)key</code>抛出异常，程序崩溃。当然，一般情况下，这个方法我们不会使用到。</p>
<p>流程图如下：</p>
<p><img src="https://i.loli.net/2019/11/20/VjYRdXILghfma6Z.png" alt="KVC .png"></p>
<h4 id="valueForKeyPath"><a href="#valueForKeyPath" class="headerlink" title="valueForKeyPath"></a>valueForKeyPath</h4><p>事实上，<code>KVC</code>除了提供<code>valueForKey</code>方法来获取值之外，还提供了<code>valueForKeyPath</code>的取值方法，区别在于<code>valueForKeyPath</code>可以<em>按路径取值</em>，比如：假设<code>person</code>实例对象有一个<code>dog</code>属性，<code>dog</code>自身又存在一个<code>name</code>属性，那么我们可以使用<code>valueForKeyPath</code>的取值方法来获取<code>dog</code>的<code>name</code>属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id dogName = [person valueForKeyPath: @&quot;dog.name&quot;]</span><br></pre></td></tr></table></figure>

<p>这个原理差不多，就不赘述了。</p>
<h2 id="KVC之设值"><a href="#KVC之设值" class="headerlink" title="KVC之设值"></a>KVC之设值</h2><p>既然<code>KVC</code>可以获取值，反之，也一定可以设置值，从上面我们可以知道，<code>KVC</code>的取值的成员变量有<code>4</code>个，并且有着优先级，即：<code>_key</code> &gt; <code>_isKey</code> &gt; <code>key</code> &gt; <code>isKey</code>。那么，同样的，当我们使用<code>KVC</code>的<code>setValue:value forKey:key</code>方法时，<strong><code>KVC</code>也会去查找相应的<code>4</code>个成员变量，并且设置值的优选级完全和<code>KVC</code>取值一样！（前提条件是没有相应的<code>setter</code>方法，这个稍后会讲）</strong></p>
<p>同样地，我们来测试一下：</p>
<p><code>Person.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">	NSString *_name;</span><br><span class="line">	NSString *_isName;</span><br><span class="line">	NSString *name;</span><br><span class="line">	NSString *isName;</span><br><span class="line">&#125;</span><br><span class="line">- (void)printName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>Person.m</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">	NSLog(@&quot;_name: %@&quot;, _name);</span><br><span class="line">	NSLog(@&quot;_isName: %@&quot;, _isName);</span><br><span class="line">	NSLog(@&quot;name: %@&quot;, name);</span><br><span class="line">	NSLog(@&quot;isName: %@&quot;, isName);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>ViewController.m</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	[self test];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">	Person *p = [[Person alloc] init];</span><br><span class="line">	[p setValue:@&quot;test name&quot; forKey:@&quot;name&quot;];</span><br><span class="line">	[p printName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>执行程序，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_name: test name</span><br><span class="line">_isName: (null)</span><br><span class="line">name: (null)</span><br><span class="line">isName: (null)</span><br></pre></td></tr></table></figure>

<p>可以看出，先设置的是<code>_name</code>的值，去掉<code>_name</code>，就会设置<code>_isName</code>的值，其它同理。</p>
<p>需要注意的是，如果设置的成员变量不存在，那么程序将调用<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>抛出异常，直接奔溃，这个和<code>KVC</code>取值时找不到<code>getter</code>方法、成员变量时调用<code>- (id)valueForUndefinedKey:(NSString *)key</code>是一样的道理。</p>
<p>同理，<code>KVC</code>取值有<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法，<code>KVC</code>设值也是同一个方法，若没有相应的<code>setter</code>方法，并且返回<code>NO</code>时，程序将调用<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>抛出异常，因此，为了防止异常，我们有时候可以重写<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>方法以防止奔溃。另外，值得一提的是，<code>KVC</code>在给数值型数据类型如<code>NSInteger</code>设值<code>nil</code>值的话，会调用<code>- (void)setNilValueForKey:(NSString *)key</code>抛出异常。比如：</p>
<p>在<code>Person.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	NSInteger age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ViewController.m</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">[p setValue:nil forKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure>

<p>毫无疑问，程序将奔溃！因此，仅仅重写<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>方法是不够的的，要同时重写<code>- (void)setNilValueForKey:(NSString *)key</code>，防止程序奔溃！</p>
<p>在<code>KVC</code>取值中，有<code>5</code>个<code>getter</code>方法，但是在<code>KVC</code>设值中，只有<code>2</code>个<code>setter</code>方法，分别是：<code>setKey</code>、<code>setIsKey</code>，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">	NSLog(@&quot;setter name: %@&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setIsName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">	NSLog(@&quot;setter isName: %@&quot;, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级：<code>setName</code> &gt; <code>setIsName</code>，也即是 <code>setKey</code> &gt; <code>setIsKey</code>。</p>
<p>和<code>KVC</code>取值是一个道理，若有以上所说的<code>2</code>个<code>setter</code>方法，则优先执行<code>setter</code>方法，忽略成员变量在初始化时的值。没有<code>setter</code>方法，就判断<code>+ (BOOL)accessInstanceVariablesDirectly</code>的返回值是否为<code>NO</code>，若为<code>NO</code>，调用<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>抛出异常（没有重写该方法则崩溃），若为<code>YES</code>，就去查找相应的成员变量并赋值。</p>
<h2 id="手动写一个KVC"><a href="#手动写一个KVC" class="headerlink" title="手动写一个KVC"></a>手动写一个KVC</h2><p>参照<code>KVC</code>的设值和取值的基本流程，我们也可以自己手动写一个属于自己的<code>KVC</code>。具体说明这里就不介绍了，有兴趣可直接查看源码，都是一些简单的业务逻辑判断，利用<code>OC</code>的<code>runtime机制</code>，实现出相应的<code>KVC</code>效果。</p>
<p><a href="https://github.com/lchenfox/OC_KVCDemo" target="_blank" rel="noopener">查看KVC源码</a></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title>六 Python函数</title>
    <url>/2019/11/19/%E5%85%AD%20Python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>函数的调用非常简单，<code>python</code>提供了很多内置函数供我们使用，比如：</p>
<p>获取绝对值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-123)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>求多个数中的最大值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; max(1, 2, 3)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>求多个数中的最小值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; min(0, -1, 99)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>类型转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;123&apos;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; str(-99)</span><br><span class="line">&apos;-99&apos;</span><br></pre></td></tr></table></figure>

<p>以上的方法和形式与<code>Swift</code>语言十分相似，<code>abs()函数</code>、<code>max()函数</code>、<code>min()函数</code>甚至和<code>Swift</code>的<code>API</code>一模一样，包括形式和用法。</p>
<p>再比如，<code>python</code>也提供了<code>hex()函数</code>将一个<code>整数</code>(注意：必须是整数，否则就会报错)转换成一个<code>十六进制表示的字符串</code>。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(22)</span><br><span class="line">&apos;0x16&apos;</span><br><span class="line">&gt;&gt;&gt; hex(99)</span><br><span class="line">&apos;0x63&apos;</span><br></pre></td></tr></table></figure>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h4 id="使用def定义函数"><a href="#使用def定义函数" class="headerlink" title="使用def定义函数"></a>使用<code>def</code>定义函数</h4><p>例如，创建一个<code>demo.py</code>文件，定义一个<code>test(a, b)</code>函数，并传入参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test(a, b):</span><br><span class="line">	if a &gt; b:</span><br><span class="line">		print(&apos;a &gt; b&apos;)</span><br><span class="line">	elif a == b:</span><br><span class="line">		print(&apos;a = b&apos;)</span><br><span class="line">	else:</span><br><span class="line">		print(&apos;a &lt; b&apos;)</span><br><span class="line">test(5, 10)</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 demo.py</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &lt; b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：我们也可以在当前目录下，进入<code>python交互式环境</code>，然后使用<code>from demo import test</code>的形式导出该<code>demo.py</code>里面具体函数，<code>demo</code>是文件名，注意没有<code>.py</code>后缀，<code>test</code>是函数名，然后在交互式环境下使用<code>test(a, b)</code>函数。</p>
</blockquote>
<h4 id="pass占位符"><a href="#pass占位符" class="headerlink" title="pass占位符"></a><code>pass</code>占位符</h4><p>有时候，我们可以在函数或一些程序中使用<code>pass</code>来作为占位符，比如定义一个函数，但是里面没有任何内容，执行就会报错，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fuck():</span><br></pre></td></tr></table></figure>

<p>执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 demo.py</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">  File &quot;demo.py&quot;, line 2</span><br><span class="line"></span><br><span class="line">               ^</span><br><span class="line">SyntaxError: unexpected EOF while parsing</span><br></pre></td></tr></table></figure>

<p>那想留住这个函数，后面在写函数体里面的内容怎么办呢？有<code>2种</code>方式，第一，使用<code>pass</code>，第二，使用<code>return</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fuck():</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fuck():</span><br><span class="line">	return</span><br></pre></td></tr></table></figure>

<p>这样执行<code>python文件</code>，就可以执行里面的程序而不会因为一个<code>空函数</code>而报错。</p>
<h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>数据类型检查直接使用内置函数<code>isinstance()函数</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test1(a):</span><br><span class="line">	if isinstance(a, (int, float)):</span><br><span class="line">		print(&apos;you passed an int type&apos;)</span><br><span class="line">	else:</span><br><span class="line">		raise TypeError(&apos;What the fucking are you doing?&apos;)</span><br><span class="line"></span><br><span class="line">def test2(b):</span><br><span class="line">	if not isinstance(b, (str)):</span><br><span class="line">		print(&apos;the parameter you passed is not str type&apos;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from demo import test1</span><br><span class="line">&gt;&gt;&gt; test1(1)</span><br><span class="line">you passed an int type</span><br><span class="line">&gt;&gt;&gt; test1(2.2)</span><br><span class="line">you passed an int type</span><br><span class="line">&gt;&gt;&gt; test1(&apos;1&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/Users/langke/Desktop/demo.py&quot;, line 5, in test1</span><br><span class="line">    raise TypeError(&apos;What the fucking are you doing?&apos;)</span><br><span class="line">TypeError: What the fucking are you doing?</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from demo import test2</span><br><span class="line">&gt;&gt;&gt; test2(1)</span><br><span class="line">the parameter you passed is not str type</span><br></pre></td></tr></table></figure>

<h4 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h4><p><code>python</code>的函数返回多个值的时候，事实上是返回一个元组（<code>tuple</code>），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func1(a, b):</span><br><span class="line">	a = pow(a, 2)</span><br><span class="line">	b = pow(b, 2)</span><br><span class="line">	return a, b</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3</span><br><span class="line">Python 3.7.4 (default, Sep  7 2019, 18:27:02)</span><br><span class="line">[Clang 10.0.1 (clang-1001.0.46.4)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; from demo import func1</span><br><span class="line">&gt;&gt;&gt; m, n = func1(3, 4)</span><br><span class="line">&gt;&gt;&gt; print(m)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; print(n)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; func1(5, 7)</span><br><span class="line">(25, 49)</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p><em>位置参数</em>就是正常的参数传递，别想复杂了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fuckYou(name):</span><br><span class="line">	print(&apos;name is %s&apos; % name)</span><br></pre></td></tr></table></figure>

<p>在上面的<code>fuckYou函数</code>中，<code>name</code>就是所谓的<em>位置参数</em>。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p><em>默认参数</em>就是在函数调用的时候，给部分参数设置一个默认的初始值的参数。这个其实也很好理解，现在很多语言都提供默认参数了，比如<code>JavaScript</code>、<code>Swift</code>等等，<em>默认参数</em>在有的时候可以简化我们的代码。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fuck(name, gender = &apos;girl&apos;, age = 18):</span><br><span class="line">	print(&apos;name is &#123;0&#125;, gender is &#123;1&#125;, age is &#123;2&#125;&apos;.format(name, gender, age))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from demo import fuck</span><br><span class="line">&gt;&gt;&gt; fuck(&apos;langke&apos;)</span><br><span class="line">name is langke, gender is girl, age is 18</span><br><span class="line">&gt;&gt;&gt; fuck(&apos;Alice&apos;, &apos;boy&apos;)</span><br><span class="line">name is Alice, gender is boy, age is 18</span><br><span class="line">&gt;&gt;&gt; fuck(&apos;Joe&apos;, age = 38)</span><br><span class="line">name is Joe, gender is girl, age is 38</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在<code>python</code>中，当提供多个默认参数，并且在调用的时候，如果不按顺序调用后面的某个默认参数，就需要指定需要改变的那个默认参数名，比如上面的调用<code>fuck(&#39;Joe&#39;, age = 38)</code>，需要改变默认参数<code>age</code>的值，但是默认参数<code>age</code>前面的默认参数<code>gender</code>保持不变（继续使用默认参数值），那么就需要指定<code>age</code>这个参数名，否则，直接传入参数的话，在函数内部就会一一对应。</p>
</blockquote>
<p>另外，当使用默认参数的时候，也要注意，一般情况下，默认参数尽量是<em>不可变参数值</em>，如果是可变的话（比如数组，数组是一个引用类型对象），那么就会造成数据修改。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def appendElement(arr = []):</span><br><span class="line">	arr.append(&apos;python&apos;)</span><br><span class="line">	return arr</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from demo import appendElement</span><br><span class="line">&gt;&gt;&gt; appendElement()</span><br><span class="line">[&apos;python&apos;]</span><br><span class="line">&gt;&gt;&gt; appendElement()</span><br><span class="line">[&apos;python&apos;, &apos;python&apos;]</span><br><span class="line">&gt;&gt;&gt; appendElement()</span><br><span class="line">[&apos;python&apos;, &apos;python&apos;, &apos;python&apos;]</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用<code>None</code>空值来改造一下可变的对象参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def appendElement(arr = None):</span><br><span class="line">	if arr is None:</span><br><span class="line">		arr = []</span><br><span class="line">	arr.append(&apos;python&apos;)</span><br><span class="line">	return arr</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; appendElement()</span><br><span class="line">[&apos;python&apos;]</span><br><span class="line">&gt;&gt;&gt; appendElement()</span><br><span class="line">[&apos;python&apos;]</span><br><span class="line">&gt;&gt;&gt; appendElement()</span><br><span class="line">[&apos;python&apos;]</span><br></pre></td></tr></table></figure>

<p>因此，为了安全起见，建议一般默认参数都是用<em>不可变对象</em>，如果非要使用<em>可变对象</em>，一定要做好安全检查。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p><em>可变参数</em>就是可以传入任意个数参数，对参数不限制。在<code>python</code>中，<em>可变参数</em>可以在参数名前面加<code>*</code>号来表示这个一个<em>可变参数</em>，传入的<em>可变参数</em>在内部会转换成一个<em>元组（tuple）</em>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sum(*params):</span><br><span class="line">	print(&apos;params type is %s&apos; % type(params))</span><br><span class="line">	sum = 0</span><br><span class="line">	for param in params:</span><br><span class="line">		sum += param</span><br><span class="line">	return sum</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from demo import sum</span><br><span class="line">&gt;&gt;&gt; sum()</span><br><span class="line">params type is &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; sum(1, 2)</span><br><span class="line">params type is &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; sum(1, 2, 3)</span><br><span class="line">params type is &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>那如果我们要传入一个<em>数组</em>或<em>元组</em>将其中的元素作为<em>可变参数</em>传入怎么办呢？同样地，我们还是可以在要传入的<em>数组</em>或<em>元组</em>前面加<code>*</code>号，表示将<em>数组</em>或<em>元组</em>中的元素作为<em>可变参数</em>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(*[1, 2, 3])</span><br><span class="line">params type is &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; sum(*(4, 5, 6))</span><br><span class="line">params type is &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>哇，就是这么吊！</p>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p><em>关键字参数</em>在参数名前面加<code>**</code>表示可传入一个<em>关键字参数</em>，传入<em>关键字参数后</em>，内部会组装成一个<em>字典（dict）</em>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def obtainInfo(name, age, **params):</span><br><span class="line">	print(&apos;params type is %s&apos; % type(params))</span><br><span class="line">	print(&apos;name: %s\nage: %d\nparams: %s&apos; % (name, age, params))</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; obtainInfo(&apos;langke&apos;, 18)</span><br><span class="line">params type is &lt;class &apos;dict&apos;&gt;</span><br><span class="line">name: langke</span><br><span class="line">age: 18</span><br><span class="line">params: &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; obtainInfo(&apos;langke&apos;, 18, gender = &apos;boy&apos;, height = 1.88)</span><br><span class="line">params type is &lt;class &apos;dict&apos;&gt;</span><br><span class="line">name: langke</span><br><span class="line">age: 18</span><br><span class="line">params: &#123;&apos;gender&apos;: &apos;boy&apos;, &apos;height&apos;: 1.88&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，我们也可以在<em>字典（dict）</em>前面加<code>**</code>作为<em>关键字参数</em>传入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dicParams = &#123;</span><br><span class="line">	&apos;gender&apos;: &apos;boy&apos;,</span><br><span class="line">	&apos;height&apos;: 1.88</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; obtainInfo(&apos;langke&apos;, 18, **dicParams)</span><br><span class="line">params type is &lt;class &apos;dict&apos;&gt;</span><br><span class="line">name: langke</span><br><span class="line">age: 18</span><br><span class="line">params: &#123;&apos;gender&apos;: &apos;boy&apos;, &apos;height&apos;: 1.88&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以对<em>关键字参数</em>进行判断某个<code>key</code>是否存在，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, **params):</span><br><span class="line">	if &apos;city&apos; in params:</span><br><span class="line">		print(&apos;city exists&apos;)</span><br><span class="line">	print(name, age, params)</span><br><span class="line">person(&apos;langke&apos;, 18, city = &apos;Hangzhou&apos;)</span><br></pre></td></tr></table></figure>

<p>执行及结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py </span><br><span class="line">city exists</span><br><span class="line">langke 18 &#123;&apos;city&apos;: &apos;Hangzhou&apos;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h4><p><em>命名关键字参数</em>使用<code>*</code>号来分割前后参数，<code>*</code>号后面的参数就叫做<em>命名关键字参数</em>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city, height):</span><br><span class="line">	print(&apos;name:&#123;0&#125;, age:&#123;1&#125;, city:&#123;2&#125;, height:&#123;3&#125;&apos;.format(name, age, city, height))</span><br></pre></td></tr></table></figure>

<p>其中，<code>city</code>和<code>height</code>就是<em>命名关键字参数</em>，而且所有的<em>命名关键字参数必须指定传入值</em>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, city = &apos;Hangzhou&apos;, height = 163)</span><br><span class="line">name:langke, age:18, city:Hangzhou, height:163</span><br></pre></td></tr></table></figure>

<p>如果少了某个<em>关键字参数</em>，就会报错。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, city = &apos;Hangzhou&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() missing 1 required keyword-only argument: &apos;height&apos;</span><br></pre></td></tr></table></figure>

<p>关键字参数可以互换位置，但是必须要注意的是，关键字参数和关键字参数前面的位置参数不能调换。例如：</p>
<p>关键字参数<code>city</code>和<code>height</code>交换位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, height = 163, city = &apos;Hangzhou&apos;)</span><br><span class="line">name:langke, age:18, city:Hangzhou, height:163</span><br></pre></td></tr></table></figure>

<p><em>关键字参数</em>和<em>位置参数</em>交换位置，比如把<em>关键字参数<code>height</code></em>放在<em>位置参数<code>age</code></em>位置就报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, height = 163, 18, city = &apos;Hangzhou&apos;)</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>

<p>若函数中已经有<em>可变参数</em>，那么<em>命名关键字参数</em>就不再需要<code>*</code>号了。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, *args, city, height):</span><br><span class="line">	print(args)</span><br><span class="line">	print(&apos;name:&#123;0&#125;, age:&#123;1&#125;, city:&#123;2&#125;, height:&#123;3&#125;&apos;.format(name, age, city, height))</span><br></pre></td></tr></table></figure>

<p>调用函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, city = &apos;Hangzhou&apos;, height = 163)</span><br><span class="line">()</span><br><span class="line">name:langke, age:18, city:Hangzhou, height:163</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, *[1, 2, 3], city = &apos;Hangzhou&apos;, height = 163)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">name:langke, age:18, city:Hangzhou, height:163</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, 1, 2, 3, city = &apos;Hangzhou&apos;, height = 163)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">name:langke, age:18, city:Hangzhou, height:163</span><br></pre></td></tr></table></figure>

<p>最后，<em>命名关键字参数</em>可以有默认值（类似默认参数）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city = &apos;Hangzhou&apos;, height):</span><br><span class="line">	print(&apos;name:&#123;0&#125;, age:&#123;1&#125;, city:&#123;2&#125;, height:&#123;3&#125;&apos;.format(name, age, city, height))</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;langke&apos;, 18, height = 163)</span><br><span class="line">name:langke, age:18, city:Hangzhou, height:163</span><br></pre></td></tr></table></figure>

<h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><p><em>参数组合</em>也就是使用<em>位置参数</em>、<em>默认参数</em>、<em>可变参数</em>、<em>命名关键字参数</em>、<em>关键字参数</em>结合起来使用，但是参数定义的顺序必须是：<em>位置参数</em>、<em>默认参数</em>、<em>可变参数</em>、<em>命名关键字参数</em>、<em>关键字参数</em>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</span><br></pre></td></tr></table></figure>

<p>最后一点要注意的是，调用上面的函数我们也可以只使用<code>元组（tuple）</code>和<code>数组（list）</code>的方式传入参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归函数</strong>就是<em>自己调用自己</em>的函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def sum(n):</span><br><span class="line">	if n == 0:</span><br><span class="line">		return 0</span><br><span class="line">	return n + sum(n - 1)</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(5)</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; sum(10)</span><br><span class="line">55</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>python</code>的函数其实和其他编程语言都大同小异，需要注意的一点是函数参数的顺序，尤其是当我们使用<em>组合参数</em>时，一不小心很容易出错。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>五 Python基础之dict和set</title>
    <url>/2019/11/08/%E4%BA%94%20Python%E5%9F%BA%E7%A1%80%E4%B9%8Bdict%E5%92%8Cset/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Python</code>中内置了<code>dict</code>和<code>set</code>，<code>dict</code>也就是我们常说的<code>字典</code>。<code>dict</code>的最大好处就是取值非常快，给定一个<code>key</code>，我们可以快速获取到它对应的<code>value</code>。也正是如此，<code>dict</code>也被广泛应用在我们的实际开发当中。</p>
<p><code>set</code>，顾名思义，也就是<code>集合</code>，和我们初中学习过的数学知识一样，集合具有<code>确定性</code>、<code>无序性</code>、<code>互异性</code>，回顾一下：</p>
<ul>
<li>确定性</li>
</ul>
<p>给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现</p>
<ul>
<li>无序性</li>
</ul>
<p>元素之间没有顺序，都是无序的。</p>
<ul>
<li>互异性</li>
</ul>
<p>给定一个集合，元素不允许重复，集合中的元素都是不相同的。</p>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>dict</code>可以使用字面量初始化，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: 666&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是，<code>python</code>的字典可以是基本数据类型或一些不可变类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&apos;key1&apos;: &apos;value1&apos;, 1: &apos;one&apos;, False: &apos;False&apos;, _: &apos;_&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic[&apos;key1&apos;]</span><br><span class="line">&apos;value1&apos;</span><br><span class="line">&gt;&gt;&gt; dic[1] // 可以使用基本数据类型作为key</span><br><span class="line">&apos;one&apos;</span><br><span class="line">&gt;&gt;&gt; dic[False]  // 可以使用bool值作为key</span><br><span class="line">&apos;False&apos;</span><br><span class="line">&gt;&gt;&gt; dic[_] // 可以使用下划线_作为key</span><br><span class="line">&apos;_&apos;</span><br><span class="line">&gt;&gt;&gt; dic[0] // 当key为bool值时，可以用0代表False取值，可以用1代表True取值</span><br><span class="line">&apos;False&apos;</span><br><span class="line">&gt;&gt;&gt; dic[True] // 当key为1或者0时，可以用True代表1取值，可以用False代表0取值</span><br><span class="line">&apos;one&apos;</span><br></pre></td></tr></table></figure>

<p>但是，要注意的是，当<code>key</code>为<code>0</code>时，如果使用<code>False</code>作为<code>key</code>添加到字典，则字典的<code>key</code>还是以<code>0</code>为准，但是值会覆盖之前的值，当<code>key</code>为<code>1</code>时，也是同一个道理，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;1: &apos;a&apos;, 0: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;1: &apos;a&apos;, 0: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic[True] = &apos;True&apos;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;1: &apos;True&apos;, 0: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic[False] = &apos;False&apos;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;1: &apos;True&apos;, 0: &apos;False&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>同样地，当<code>key</code>为<code>True</code>或<code>False</code>时，添加<code>1</code>或<code>0</code>作为<code>key</code>添加到字典，仍然是以<code>True</code>或<code>False</code>为<code>key</code>，只是值会被覆盖，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;True: &apos;a&apos;, False: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic[1] = 666</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;True: 666, False: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic[0] = 555</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;True: 666, False: 555&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，当你的<code>key</code>为<code>1</code>时，这时往字典添加<code>True</code>作为<code>key</code>时，<code>Python</code>内部会将你的<code>True</code>转化为<code>1</code>，然后判断原来的<code>dic</code>里面已经有<code>1</code>，因此<code>key</code>保持不变，值被覆盖。反之，如果用<code>bool</code>值作为<code>key</code>，再往里面添加<code>1</code>或<code>0</code>作为<code>key</code>的时候，<code>Python</code>内部会转化成<code>bool</code>值的<code>key</code>。</p>
<h4 id="添加值"><a href="#添加值" class="headerlink" title="添加值"></a>添加值</h4><p>直接通过赋值的方式往字典中添加键值对，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; dic[&apos;key3&apos;] = &apos;value3&apos;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;, &apos;key3&apos;: &apos;value3&apos;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h4><ul>
<li><code>key in dict</code></li>
</ul>
<p>使用<code>key in dict</code>的形式来判断<code>key</code>是否存在于字典<code>dict</code>中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">if &apos;key2&apos; in dic:</span><br><span class="line">	print(&apos;dic中存在key2&apos;)</span><br><span class="line">else:</span><br><span class="line">	print(&apos;dic中不存在key2&apos;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic中存在key2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dic.get(key)</code></li>
</ul>
<p>第二种方法就是通过<code>dic.get(key)</code>的形式判断，如果<code>key</code>存在，将返回<code>key</code>对应的<code>value</code>，如果<code>key</code>不存在，则返回<code>None</code>，也可以指定当<code>key</code>不存在时，返回特定的值。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">ret = dic.get(&apos;key2&apos;)</span><br><span class="line">print(&apos;ret = %s&apos; % ret)</span><br><span class="line"></span><br><span class="line">ret1 = dic.get(&apos;key3&apos;)</span><br><span class="line">print(&apos;ret1 = %s&apos; % ret1)</span><br><span class="line"></span><br><span class="line">ret2 = dic.get(&apos;key4&apos;, -9999)</span><br><span class="line">print(&apos;ret2 = &#123;0&#125;&apos;.format(ret2))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">ret = value2</span><br><span class="line">ret1 = None</span><br><span class="line">ret2 = -9999</span><br></pre></td></tr></table></figure>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>字典的删除元素方法和数组是类似的，直接使用<code>pop(key)</code>的形式，<code>pop(key)</code>删除并返回所删除的<code>key</code>对应的<code>value</code>，但是如果<code>key</code>不存在就会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; dic.pop(&apos;a&apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;b&apos;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; dic.pop(&apos;c&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &apos;c&apos;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>查找速度快（以空间换时间）</li>
<li>占用空间大，浪费内存较多</li>
<li>key必须是不可变对象</li>
</ul>
<p>为什么要求<code>key</code>是不可变，引用<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448" target="_blank" rel="noopener">廖雪峰的官方网站</a>的描述就是：</p>
<blockquote>
<p>因为<code>dict</code>根据<code>key</code>来计算<code>value</code>的存储位置，如果每次计算相同的<code>key</code>得出的结果不同，那<code>dict</code>内部就完全混乱了。这个通过<code>key</code>计算位置的算法称为哈希算法（<code>Hash</code>）。<br>要保证<code>hash</code>的正确性，作为<code>key</code>的对象就不能变。在<code>Python</code>中，字符串、整数等都是不可变的，因此，可以放心地作为<code>key</code>。比如，<code>list</code>是可变的，就不能作为<code>key</code>。</p>
</blockquote>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>在<code>Python</code>中，创建集合需要一个<code>list</code>数组作为数组，这一点很有趣：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用<code>add(key)</code>的形式来添加元素到集合中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; mySet.add(4)</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><p>使用<code>remove(key)</code>的形式直接删除元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; mySet.remove(2)</span><br><span class="line">&gt;&gt;&gt; mySet</span><br><span class="line">&#123;1, 3&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>使用<code>&amp;</code>符号求两个集合的交集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet = set([1,2,3])</span><br><span class="line">&gt;&gt;&gt; yourSet = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; mySet &amp; yourSet</span><br><span class="line">&#123;2, 3&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>使用<code>|</code>符号求两个集合的并集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mySet = set([1,2,3])</span><br><span class="line">&gt;&gt;&gt; yourSet = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; mySet | yourSet</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>set</code>和<code>dict</code>的唯一区别是没有存储对应的<code>value</code>，因为集合具有互异性，为了保证没有重复的元素，因此集合内不可以添加<strong>不可变对象</strong>。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>dict</code>和<code>set</code>的<code>key</code>必须不可变，因为要保证可哈希</li>
<li>通常情况下，建议使用<code>str</code>作为<code>dict</code>的<code>key</code></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native之Redux的使用</title>
    <url>/2019/11/08/React%20Native%E4%B9%8BRedux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Redux</code>是一个状态管理工具，提供可预测化的状态管理。在应用中，我们经常使用<code>state</code>和<code>props</code>来管理组件的数据流，以及组件与组件之间的数据传递，然后更新<code>UI</code>，通常情况下，如果应用不大，代码规范优秀，业务逻辑处理得当，那么使用<code>state</code>和<code>props</code>没有任何问题，我们也用不着所谓的<code>Redux</code>来管理应用的状态。</p>
<p>但是，随着应用的逐渐庞大，业务逻辑变得越来越复杂，这时候，我们发现，有些组件与组件之间的值的传递（<code>props</code>）会变得很困难，修改了这个组件，另一个组件也要保持同步、刷新等等操作，我们会使用<code>block</code>、<code>Notification</code>、<code>缓存</code>等操作来保持应用的最新状态，一不小心，容易出错，在这种情况下，有一个好的工具来替我们来管理整个应用的状态，那就太棒了，而<code>Redux</code>正是帮我们做这一复杂逻辑的一个状态管理工具，让我们可以独立地在任何地方获取到整个应用的状态。</p>
<p><a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">Redux在GitHub地址。</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>action</li>
</ul>
<p><code>action</code>就是一个普通的对象，用来描述某一种行为。</p>
<ul>
<li>reducer</li>
</ul>
<p><code>reducer</code>是一个纯函数，用来计算、合并在产生行为后的<code>state</code>数据，返回一个全新的<code>state</code>到<code>store</code>。之所以叫纯函数，是因为在<code>reducer</code>函数中，只做数据的合并、处理操作，不会调用任何<code>API</code>，也不会改变外部的<code>state</code>数据。</p>
<ul>
<li>store</li>
</ul>
<p><code>store</code>是一个存储整个应用的<code>state树</code>，它保存了整个应用的状态信息，重要的是，任何应用，有且只有一个<code>store</code>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在使用之前，我们需要安装的三方库如下：</p>
<ul>
<li>redux</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save redux</span><br></pre></td></tr></table></figure>

<ul>
<li>react-redux</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>react-redux</code>是<code>redux</code>的官方<code>react</code>绑定库，提供一些组件关联函数、状态传递<code>provider</code>等。</p>
</blockquote>
<ul>
<li>redux-thunk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install redux-thunk</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redux-thunk</code>是一个<code>Middleware</code>，与<code>redux</code>组合可调用异步函数。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h4><p><img src="https://i.loli.net/2019/11/08/5BjCJyZeXbIQAct.gif" alt="gif.gif"></p>
<blockquote>
<p>注：假设你已经熟悉创建<code>React Native</code>工程，如何创建这里不再详细说明，若不懂的话可移步到：<a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native官网</a> 或者 <a href="https://reactnative.cn/" target="_blank" rel="noopener">React Native中文网</a>。</p>
</blockquote>
<h4 id="工程目录结构"><a href="#工程目录结构" class="headerlink" title="工程目录结构"></a>工程目录结构</h4><blockquote>
<p>注：目录可根据自己需要，并不是觉得，只要你觉得方便、合理、低耦合即可。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/11/08/ORrSku1mWZUzeAa.png" alt="proj_structure"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h6 id="Action目录"><a href="#Action目录" class="headerlink" title="Action目录"></a>Action目录</h6><ul>
<li>ActionType.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ADD_NAME = &apos;ADD_NAME&apos;;</span><br></pre></td></tr></table></figure>

<p>用于描述<code>action</code>的类型，也就是某种行为，一般建议用字符串常量。</p>
<ul>
<li>NameAction.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;ADD_NAME&#125; from &quot;./ActionType&quot;;</span><br><span class="line"></span><br><span class="line">export const addName = data =&gt; (&#123;</span><br><span class="line">    type: ADD_NAME,</span><br><span class="line">    data,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个文件主要用于创建<code>action</code>对象，根据<code>Redux</code>标准，每一个对象，必须有一个<code>type</code>字段，用于描述要触发的类型。</p>
<h6 id="Reducer目录"><a href="#Reducer目录" class="headerlink" title="Reducer目录"></a>Reducer目录</h6><ul>
<li>NameReducer.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;ADD_NAME&#125; from &quot;../Action/ActionType&quot;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123;</span><br><span class="line">    data: [</span><br><span class="line">        &#123;</span><br><span class="line">            title: &apos;test0&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export const nameReducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case ADD_NAME:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                data: state.data.concat(action.data),</span><br><span class="line">            &#125;;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建<code>reducer</code>函数即<code>nameReducer</code>，接受先前的<code>state</code>，默认有一个初始值；第二个参数是<code>action</code>，也就是当触发操作后接受到的<code>action</code>对象，里面包含了类型<code>type</code>和数据（数据是非必须的，根据需要看是否传入）。</p>
<p>如果找不到类型，默认返回先前的<code>state</code>状态。</p>
<ul>
<li>index.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;combineReducers&#125; from &apos;redux&apos;;</span><br><span class="line">import &#123;nameReducer&#125; from &apos;./NameReducer&apos;;</span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">    nameReducer,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure>

<p>通过<code>redux</code>提供的<code>combineReducers</code>将所有的<code>reducer</code>组合成一个<code>rootReducer</code>（这里为了方便，只写了一个<code>reducer</code>）。</p>
<h6 id="Store目录"><a href="#Store目录" class="headerlink" title="Store目录"></a>Store目录</h6><ul>
<li>Store.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;createStore&#125; from &apos;redux&apos;;</span><br><span class="line">import rootReducer from &quot;../Reducer&quot;;</span><br><span class="line">const store = createStore(rootReducer);</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure>

<p><code>store</code>的职责是维持整个应用的状态，创建<code>store</code>也很简单，直接使用<code>Redux</code>提供的函数<code>createStore</code>，传入上一步创建的<code>rootReducer</code>即可，这样，<code>redux</code>相关的东西准备得差不多了，接下来该在我们的组件里面，绑定我们的<code>store</code>、触发<code>action</code>就好了。</p>
<h6 id="Component目录"><a href="#Component目录" class="headerlink" title="Component目录"></a>Component目录</h6><ul>
<li>Home.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">    View,</span><br><span class="line">    FlatList,</span><br><span class="line">    TouchableOpacity,</span><br><span class="line">    Text,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line">import &#123;connect&#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123;addName&#125; from &apos;../Action/NameAction&apos;;</span><br><span class="line">import styles from &quot;./styles&quot;;</span><br><span class="line"></span><br><span class="line">const buttonText = &apos;Add Name&apos;;</span><br><span class="line">let index = 0;</span><br><span class="line"></span><br><span class="line">class Home extends Component &#123;</span><br><span class="line"></span><br><span class="line">    _addName = () =&gt; &#123;</span><br><span class="line">        index += 1;</span><br><span class="line">        const data = [&#123;title: `test$&#123;index&#125;`&#125;];</span><br><span class="line">        this.props.addName(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _renderItem = (&#123;item&#125;) =&gt; &#123;</span><br><span class="line">        const &#123;title&#125; = item;</span><br><span class="line">        return (&lt;View style=&#123;styles.cell&#125;&gt;</span><br><span class="line">            &lt;Text&gt;&#123;title&#125;&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;View style=&#123;styles.navigationBar&#125;/&gt;</span><br><span class="line">                &lt;TouchableOpacity onPress=&#123;this._addName&#125;&gt;</span><br><span class="line">                    &lt;Text style=&#123;styles.nameButtonText&#125;&gt;&#123;buttonText&#125;&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">                &lt;View style=&#123;styles.line&#125;/&gt;</span><br><span class="line">                &lt;FlatList</span><br><span class="line">                    renderItem=&#123;this._renderItem&#125;</span><br><span class="line">                    data=&#123;this.props.data&#125;</span><br><span class="line">                    keyExtractor=&#123;(item, index) =&gt; index.toString()&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state =&gt; (&#123;</span><br><span class="line">    data: state.nameReducer.data,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">    addName: data =&gt; dispatch(addName(data))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps,</span><br><span class="line">)(Home);</span><br></pre></td></tr></table></figure>

<p>在这个组件中，最重要的一个步骤是使用<code>react-redux</code>提供的<code>connect</code>函数，将<code>Home</code>组件和我们的<code>redux</code>关联起来，这样就可以获取到<code>store</code>中的<code>state</code>，触发<code>action</code>。</p>
<p><strong>mapStateToProps</strong>： 主要用于将<code>store</code>中的<code>state</code>映射到当前组件的<code>props</code>，这样的话，我们就可以在组件中通过<code>this.props</code>的形式获取需要的数据。<code>state.nameReducer.data</code>中的<code>nameReducer</code>就是<code>Reducer目录</code>下的<code>index.js</code>里面的<code>nameReducer</code>，最终其实就是<code>NameReducer.js</code>文件中的纯函数<code>nameReducer</code>，里面的<code>data</code>也就是从<code>store</code>取出来的最新<code>state</code>数据，在<code>render</code>函数里面，我们使用<code>this.props.data</code>拿到最新的列表数据。</p>
<p><strong>mapDispatchToProps：</strong> 主要用于将<code>dispatch(action)</code>操作映射到当前的<code>Home</code>组件中，我们可以看到，在<code>_addName</code>点击事件里面，使用了<code>this.props.addName(data);</code>，这个<code>this.props.addName</code>就是<code>mapDispatchToProps</code>的功劳。<code>dispatch(addName(data))</code>中的<code>addName</code>就是之前我们创建的<code>action</code>对象（你也可以理解成一个函数），即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const addName = data =&gt; (&#123;</span><br><span class="line">    type: ADD_NAME,</span><br><span class="line">    data,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样的话，当我们点击按钮来调用<code>_addName</code>的使用，通过<code>dispatch</code>来触发<code>addName()</code>这个<code>action</code>，然后触发<code>nameReducer</code>，最后通过<code>this.props.data</code>获取到最新的<code>state</code>数据来刷新<code>UI</code>。</p>
<ul>
<li>styles.js</li>
</ul>
<p>这里面都是存储组件里面的样式，使组件里面更加关注业务逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;StyleSheet&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default StyleSheet.create(&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">    navigationBar: &#123;</span><br><span class="line">        height: 88,</span><br><span class="line">    &#125;,</span><br><span class="line">    nameButtonText: &#123;</span><br><span class="line">        height: 50,</span><br><span class="line">        padding: 15,</span><br><span class="line">        backgroundColor: &apos;black&apos;,</span><br><span class="line">        color: &apos;white&apos;,</span><br><span class="line">        alignSelf: &apos;center&apos;,</span><br><span class="line">        borderRadius: 10,</span><br><span class="line">    &#125;,</span><br><span class="line">    cell: &#123;</span><br><span class="line">        height: 50,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        marginLeft: 15,</span><br><span class="line">        marginRight: 15,</span><br><span class="line">        borderBottomWidth: 0.5,</span><br><span class="line">        borderBottomColor: &apos;blue&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    line: &#123;</span><br><span class="line">        marginTop: 15,</span><br><span class="line">        backgroundColor: &apos;green&apos;,</span><br><span class="line">        height: 0.5,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a>App.js</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import Home from &quot;./Redux/Component/Home&quot;;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;;</span><br><span class="line">import Store from &apos;./Redux/Store/Store&apos;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Provider store=&#123;Store&#125;&gt;</span><br><span class="line">                &lt;Home/&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>App.js</code>是最重要的一个节点，因为它是我们的根组件，我要要使用<code>Redux</code>并在全局的其他子组件获取到<code>state</code>，那么就要在根组件的最外层包括一个<code>Provider</code>容器，不必担心，这个在<code>react-redux</code>中已经给我们准备好了，我们要做的就是直接导入使用即可。</p>
<p>这里的<code>Store</code>也就是我们之前通过<code>createStore(rootReducer)</code>创建的并且唯一的一个<code>store</code>，它在全局起着至关重要的作用，因为我们所有的数据都是存放在这个<code>store</code>中，它维持的是一棵完整的<code>state</code>树，有了它，你可以在其他任意组件通过<code>connect</code>获取到当前<code>store</code>中存储的数据和状态。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>action是一个对象，用于描述某一个动作或行为，可以传入数据</li>
<li>reducer是一个纯函数，主要用于处理<code>state</code>数据，返回全新的<code>state</code>数据</li>
<li>store整个应用中只有一个，维持着所有的<code>state</code>数据，我们可以在任意组件通过<code>connect</code>获取</li>
</ul>
<blockquote>
<p>本文虽然引入了<code>redux-thunk</code>，由于篇幅有限，并未使用，放在下一篇文章中进行讲解。</p>
</blockquote>
<p>本文源码：<a href="https://github.com/lchenfox/RN_ReduxDemo" target="_blank" rel="noopener">RN_ReduxDemo</a></p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>Redux</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native使用react-native-pushy热更新审核被拒</title>
    <url>/2019/11/05/React%20Native%E4%BD%BF%E7%94%A8react-native-pushy%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>今年，综合了一些考虑，选择了 <a href="https://github.com/reactnativecn/react-native-pushy" target="_blank" rel="noopener">GitHub: react-native-pushy</a> 作为热更新，在前面的两个版本使用了热更新，但是没有被拒，上线都比较顺利，直到这个版本，第二天直接被苹果拒绝！前有<code>WaxPatch</code>和<code>JSPatch</code>等热修复框架，因为会调用私有API、篡改原生代码的能力而被苹果拒之门外，接着苹果允许<code>React Native</code>的这种不会修改原生代码、只更新<code>js代码</code>和一些资源文件的热修复存在。如今，陆陆续续已经有一部分人因为使用<code>react-native-pushy</code>热更新而直接被苹果拒绝。</p>
<h3 id="被拒原因"><a href="#被拒原因" class="headerlink" title="被拒原因"></a>被拒原因</h3><hr>
<h5 id="理由如下："><a href="#理由如下：" class="headerlink" title="理由如下："></a>理由如下：</h5><p>2019年10月26日 上午12:17</p>
<p>发件人 Apple</p>
<p>2.3 Performance: Accurate Metadata</p>
<p>2.5 Performance: Software Requirements</p>
<p>Guideline 2.3.1 - Performance</p>
<p>We discovered that your app contains hidden features.</p>
<p>The next submission of this app may require a longer review time, and this app will not be eligible for an expedited review until this issue is resolved.</p>
<p>Next Steps</p>
<ul>
<li>Review the Performance section of the App Store Review Guidelines.</li>
<li>Ensure your app is compliant with all sections of the App Store Review Guidelines and the Terms &amp; Conditions of the Apple Developer Program.</li>
<li>Once your app is fully compliant, resubmit your app for review.</li>
</ul>
<p>Submitting apps designed to mislead or harm customers or evade the review process may result in the termination of your Apple Developer Program account. Review the Terms &amp; Conditions of the Apple Developer Program to learn more about our policies regarding termination.</p>
<p>Guideline 2.5.2 - Performance - Software Requirements</p>
<p>Your app, extension, or linked framework appears to contain code designed explicitly with the capability to change your app’s behavior or functionality after App Review approval, which is not in compliance with App Store Review Guideline 2.5.2 and section 3.3.2 of the Apple Developer Program License Agreement.</p>
<p>This code, combined with a remote resource, can facilitate significant changes to your app’s behavior compared to when it was initially reviewed for the App Store. While you may not be using this functionality currently, it has the potential to load private frameworks, private methods, and enable future feature changes. This includes any code which passes arbitrary parameters to dynamic methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), and running remote scripts in order to change app behavior and/or call SPI, based on the contents of the downloaded script. Even if the remote resource is not intentionally malicious, it could easily be hijacked via a Man In The Middle (MiTM) attack, which can pose a serious security vulnerability to users of your app.</p>
<p>The next submission of this app may require a longer review time, and this app will not be eligible for an expedited review until this issue is resolved.</p>
<p>Next Steps</p>
<ul>
<li>Review the Software Requirements section of the App Store Review Guidelines.</li>
<li>Ensure your app is compliant with all sections of the App Store Review Guidelines and the Terms &amp; Conditions of the Apple Developer Program.</li>
<li>Once your app is fully compliant, resubmit your app for review.</li>
</ul>
<p>Submitting apps designed to mislead or harm customers or evade the review process may result in the termination of your Apple Developer Program account. Review the Terms &amp; Conditions of the Apple Developer Program to learn more about our policies regarding termination.</p>
<p>显然，苹果的大意如下：</p>
<ul>
<li>1.App隐藏了功能</li>
<li>2.审核通过后，具备修改应用程序的行为或功能的能力</li>
<li>3.检测到APP获取远程资源，或许会调用私有API及私有方法，利用动态特性给动态方法传递参数，如<code>dlopen()、dlsym()、respondsToSelector:、performSelector:、method_exchange()</code>，易受<code>MiTM</code>攻击，下发恶意脚本等等</li>
</ul>
<p>回复很官方，也没有明确指出是<strong>热更新</strong>的原因，但是有部分人收到被拒的理由里面明确致命了使用<code>Hot Update</code>热更新。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><hr>
<ul>
<li><p>2019年10月24日提交</p>
</li>
<li><p>2019年10月25日被拒</p>
</li>
<li><p>2019年10月26日去掉<code>jenkins+fastlane</code>自动化打包脚本（以为是这个原因，毕竟之前的版本使用热更新没有被拒）重新打包上传到<code>App Store Connect</code></p>
</li>
<li><p>截止2019年10月30日依然在审核中</p>
</li>
<li><p>10月30日中午去掉<code>iOS</code>的热更新，并再次打包重新上传，去掉热更新的步骤：</p>
</li>
</ul>
<p><strong>（1）修改AppDelegate为</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    NSURL *jsCodeLocation;</span><br><span class="line">#if DEBUG</span><br><span class="line">    // 原来的jsCodeLocation保留在这里</span><br><span class="line">    jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil];</span><br><span class="line">#else</span><br><span class="line">    // 非DEBUG情况下启用热更新</span><br><span class="line">    jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br><span class="line">//    jsCodeLocation=[RCTHotUpdate bundleURL];  // 不要热更新</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>（2）删除<code>Libraries -&gt; RCTHotUpdate.xcodeproj</code></strong></p>
<p><strong>（3）注释掉所有热更新的js检测代码</strong>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/****************** hot update *********************/</span><br><span class="line">/*</span><br><span class="line">import &#123;</span><br><span class="line">    isFirstTime,</span><br><span class="line">    isRolledBack,</span><br><span class="line">    packageVersion,</span><br><span class="line">    currentVersion,</span><br><span class="line">    checkUpdate,</span><br><span class="line">    downloadUpdate,</span><br><span class="line">    switchVersion,</span><br><span class="line">    switchVersionLater,</span><br><span class="line">    markSuccess,</span><br><span class="line">&#125; from &apos;react-native-update&apos;;</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">const &#123;appKey&#125; = _updateConfig[Platform.OS];</span><br><span class="line"></span><br><span class="line">export default class rootApp extends Component &#123;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">         this._checkHotUpdateVersion();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    _checkHotUpdateVersion = (tryAgain = true) =&gt; &#123;</span><br><span class="line">        checkUpdate(appKey).then(info =&gt; &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;).catch(() =&gt; &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">**/</span><br></pre></td></tr></table></figure>

<ul>
<li>11月5日凌晨2点22分，审核通过！！！</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>之前使用热更新没有问题，从目前大多数人由于使用热更新审核被拒的情况来看，苹果开始着手清理了，并且后续支不支持热更新也很难说，尽管一部分人还是通过了审核，但是不排除审核遗漏的情况。</p>
<p>初步猜测，后续苹果可能不支持热更新，尽管不修改原生代码，不调用原生私有<code>API</code>，但毕竟热更新的服务器一般是托管在第三方平台上，但是在苹果看来，只要不通过其审核的，都是不安全的。</p>
<p>其次，尽管只是修改<code>js</code>及一些资源文件，但是从对用户体验方面来说，苹果可能会觉得使用热更新会随意更改用户的习惯，会给用户造成体验方面的一系列问题。</p>
<p>最后，也是苹果觉得最危险的地方在于，担心<code>MiTM攻击</code>，另外我个人觉得，苹果还有一个想法，那就是希望开发者回归原生生态，毕竟，使用自己的语言，经过自己的审核才是苹果最希望的。</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native, react-native-pushy, 热更新, 苹果审核</tag>
      </tags>
  </entry>
  <entry>
    <title>四 Python基础之条件语句和循环</title>
    <url>/2019/11/04/%E5%9B%9B%20Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>在<code>Python</code>中，最常用的判断自然就是<code>if语句</code>，可以使用<code>if ... elif ... else</code>来对条件进行判断，和其他一些语言不同的是，这里的<code>elif</code>是<code>else if</code>的缩写，但是这意味着在<code>Python</code>中，我们可以使用<code>else if</code>来代替<code>elif</code>呢？千万要注意，是不允许的！！必须使用<code>elif</code>的形式。</p>
<p>创建一个<code>demo.py</code>文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age = 19</span><br><span class="line">if age:</span><br><span class="line">    print(&apos;age exists&apos;)</span><br><span class="line"></span><br><span class="line">weight = 119</span><br><span class="line">if weight &gt; 150:</span><br><span class="line">    print(&apos;you are obese!&apos;)</span><br><span class="line">elif weight &gt; 100:</span><br><span class="line">    print(&apos;Great, you are handsome!&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;Um...you are too thin!&apos;)</span><br></pre></td></tr></table></figure>

<p>可以尝试执行一下，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">age exists</span><br><span class="line">Great, you are handsome!</span><br></pre></td></tr></table></figure>

<p>基本逻辑和其他语言几乎没什么不同，主要注意关键字和基本格式比如缩进、冒号就行了。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for ... in ...循环"></a><code>for ... in ...</code>循环</h5><p>使用<code>for ... in ...</code>循环，我们可以遍历出<code>list</code>或<code>tuple</code>的元素，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">names = [&apos;Jhone&apos;, &apos;Alice&apos;, &apos;Joe&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(&apos;name is %s&apos; % name)</span><br><span class="line"></span><br><span class="line">ages = (1, 2, 3, 4, 5)</span><br><span class="line">for age in ages:</span><br><span class="line">    print(&apos;age is &#123;0&#125;&apos;.format(age))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name is Jhone</span><br><span class="line">name is Alice</span><br><span class="line">name is Joe</span><br><span class="line">age is 1</span><br><span class="line">age is 2</span><br><span class="line">age is 3</span><br><span class="line">age is 4</span><br><span class="line">age is 5</span><br></pre></td></tr></table></figure>

<h5 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h5><p><code>Python</code>内置了一个函数叫做<code>range()</code>，可以生成一个有序的<strong>整数序列</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">values = range(5)</span><br><span class="line">for value in values:</span><br><span class="line">	print(&apos;value is %d&apos; % value)</span><br><span class="line"></span><br><span class="line">ages = range(2, 6)</span><br><span class="line">for age in ages:</span><br><span class="line">	print(&apos;age is &#123;0&#125;&apos;.format(age))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value is 0</span><br><span class="line">value is 1</span><br><span class="line">value is 2</span><br><span class="line">value is 3</span><br><span class="line">value is 4</span><br><span class="line">age is 2</span><br><span class="line">age is 3</span><br><span class="line">age is 4</span><br><span class="line">age is 5</span><br></pre></td></tr></table></figure>

<p>从以上结果可以看出，当只有<code>1个参数</code>的时候，也就是<code>range(x)</code>的时候，<strong>表示生成从<code>0</code>到<code>不大于x</code>的整数序列。</strong></p>
<p>若有<code>2</code>个参数的时候，也就是类似<code>range(x, y)</code>的时候，<strong>表示生成从<code>x</code>开始到<code>不大于y</code>的整数序列。</strong></p>
<p>那么问题来了，以上生成的都是从<code>x开始</code>并且不大于<code>y</code>的后面的元素都比前面的元素<code>+1</code>的序列，那如果我想要每次都<code>+2</code>而不是<code>+1</code>呢？其实，<code>range()函数</code>还有<code>3</code>个参数的表示，类似<code>range(x, y, z)</code>，后面的<code>z</code>代表的就是<code>步长</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">values = range(1, 5, 2) # 生成从1开始，元素每次递增为2并且不大于5的整数序列</span><br><span class="line">for value in values:</span><br><span class="line">	print(&apos;value is %d&apos; % (value))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">value is 1</span><br><span class="line">value is 3</span><br></pre></td></tr></table></figure>

<p>问题：求1到100的偶数之和？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">values = range(0, 101, 2)</span><br><span class="line">sum = 0</span><br><span class="line">for value in values:</span><br><span class="line">	sum += value</span><br><span class="line">print(&apos;sum is &#123;0&#125;&apos;.format(sum))</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum is 2550</span><br></pre></td></tr></table></figure>

<p>哇，感觉太方便了，有了<code>range()</code>函数，有时候真的是事半功倍呢。</p>
<h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>这个没什么好说的，和其他语言几乎是一模一样，使用也非常简单。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 5</span><br><span class="line">while a &gt; 0:</span><br><span class="line">	print(&apos;a is equal to %d&apos; % a)</span><br><span class="line">	a-=2</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">a is equal to 5</span><br><span class="line">a is equal to 3</span><br><span class="line">a is equal to 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>break</code></li>
</ul>
<p><code>break</code>的作用是结束<strong>本层循环</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret = 5</span><br><span class="line">while ret:</span><br><span class="line">	ret -= 1</span><br><span class="line">	if ret == 2:</span><br><span class="line">		break</span><br><span class="line">	print(ret)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<ul>
<li><code>continue</code></li>
</ul>
<p><code>continue</code>的作用是结束<strong>本次循环</strong>，请注意和<code>break</code>的区别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret = 5</span><br><span class="line">while ret:</span><br><span class="line">	ret -= 1</span><br><span class="line">	if ret == 2:</span><br><span class="line">		continue</span><br><span class="line">	print(ret)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  Desktop python3 demo.py</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>条件语句用<code>if...elif...else</code></p>
</li>
<li><p><code>range()</code>函数用于生成整数序列，可根据<code>步长</code>调整生成整数序列的间隔</p>
</li>
<li><p>循环有<code>for...in...</code>和<code>while</code>，根据情景取舍</p>
</li>
<li><p><code>break</code>退出本层循环，<code>continue</code>退出本次循环</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>三 Python基础之数组和元组</title>
    <url>/2019/11/04/%E4%B8%89%20Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>Python</code>中的数组是<code>list</code>, 可以通过<code>type函数</code>查看一下类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [1, 2, &apos;a&apos;, &apos;b&apos;, True, False]</span><br><span class="line">&gt;&gt;&gt; type(arr)</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>数组比较简单，和其他语言基本差不多，有一点区别是<code>Python</code>中的数组能够兼容<em>不同的数据类型(如上面)</em>。</p>
<ul>
<li>数组长度</li>
</ul>
<p>之前使用到<code>len()</code>函数，可以用来求数组元素的个数，也就是数组的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [1, 2]</span><br><span class="line">&gt;&gt;&gt; len(arr)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>index</code>获取元素</li>
</ul>
<p>数组是有序的数据结构，我们可以通过<code>索引</code>获取数组元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [1, False]</span><br><span class="line">&gt;&gt;&gt; arr[0]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>倒序的方式</code>获取数组的元素，<code>-1</code>表示最后一个元素，<code>-2</code>表示倒数第二个元素，以此类推…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; arr[-1]</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<ul>
<li>添加元素</li>
</ul>
<p>通过<code>append()</code>函数可以将元素添加到数组的末尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [1, 2]</span><br><span class="line">&gt;&gt;&gt; arr.append(3)</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<ul>
<li>插入元素</li>
</ul>
<p>可以通过<code>insert(index, value)</code>函数在指定位置插入元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">&gt;&gt;&gt; arr.insert(1, &quot;c&quot;)</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<p>可以通过<code>pop(index)</code>来删除指定位置（<code>索引</code>）的元素，如果不添加<code>index</code>，表示删除数组的最后一个元素</p>
<p>删除最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; arr.pop()</span><br><span class="line">&apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;]</span><br></pre></td></tr></table></figure>

<p>删除指定元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [&apos;a&apos;, &apos;b&apos;, True]</span><br><span class="line">&gt;&gt;&gt; arr.pop(1)</span><br><span class="line">&apos;b&apos;</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[&apos;a&apos;, True]</span><br></pre></td></tr></table></figure>

<ul>
<li>修改元素</li>
</ul>
<p><code>Python</code>中的数组修改元素十分简单，直接将要替换的元素赋值即可，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; arr = [1, 2, &apos;a&apos;, &apos;b&apos;, True]</span><br><span class="line">&gt;&gt;&gt; arr[2] = &apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; arr</span><br><span class="line">[1, 2, &apos;c&apos;, &apos;b&apos;, True]</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><code>Python</code>中有另外一种<strong>有序列表</strong>叫做<strong>元组</strong>。但是务必记住，<strong>元组一旦初始化，内部元素就不能修改，因此，一旦初始化了某个元组，你只能获取，无法改变其元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple = (1, 2, &quot;b&quot;)</span><br><span class="line">&gt;&gt;&gt; tuple[0] // 获取第一个元素</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; tuple[2] // 获取第三个元素</span><br><span class="line">&apos;b&apos;</span><br><span class="line">&gt;&gt;&gt; len(tuple) // 元组元素个数</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len[2] = 3 // 改变值，报错！！！</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;builtin_function_or_method&apos; object does not support item assignment</span><br></pre></td></tr></table></figure>

<p>很明显，<code>Python解释器</code>提示我们不能支持元组修改值。</p>
<p>另外，如果只有一个元素的元组，为了避免和日期使用的<code>小括号()</code>产生歧义，因此元组在初始化时，必须在元素后面添加<code>逗号,</code>， 否则就不是元组，而是我们日常所使用的变量。</p>
<p>这一点其实作为<code>iOS</code>开发者应该也知道，<code>Swift</code>在初始化元组时，如果只有一个元素，也需要添加<code>逗号,</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple = (1,) // 必须添加逗号</span><br><span class="line">&gt;&gt;&gt; tuple</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>

<p>当然，元组的元素不能修改，指的是元素本身，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tuple = (1, &apos;a&apos;, [2,3])</span><br><span class="line">&gt;&gt;&gt; tuple[2][0] = 4</span><br><span class="line">&gt;&gt;&gt; tuple[2][1] = 5</span><br><span class="line">&gt;&gt;&gt; tuple</span><br><span class="line">(1, &apos;a&apos;, [4, 5])</span><br></pre></td></tr></table></figure>

<p>嗯？不是说元组的元素不能修改吗？注意，这没有任何问题，上面的元组<code>tuple</code>的第<code>3</code>个元素本身是一个数组，当我们做<code>tuple[2][0] = 4</code>操作的时候，元组的元素有没有变？答案是没有！改变是只是<code>[2,3]</code>这个数组的元素，这个数组本身的地址（内存空间）是没有改变的，因此元组<code>tuple</code>的第<code>2</code>个元素的内存地址也是没有改变的，一定要注意区分。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>数组和平时使用的其他语言很相似，根据内置函数调用即可。</p>
</li>
<li><p>元组和数组很类似，但是，元组的元素只能访问，不能修改！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个性化域名配置</title>
    <url>/2019/11/03/hexo%E4%B8%AA%E6%80%A7%E5%8C%96%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当使用<code>hexo</code>结合<code>github</code>部署出我们想要的博客的时候，我们想查看自己的博客，就直接输入类似<code>xxx.github.io</code>就可以访问博客了，<code>xxx</code>就是<code>github</code>用户名，比如我的博客直接输入 <a href="http://lchenfox.github.io/" target="_blank" rel="noopener">http://lchenfox.github.io/</a> 。显然，这样的一个<code>URL</code>是比较<code>low</code>的，我们经常可以在网站上看到很多个性化的个人博客，都是用的私有域名，接下来我们一起来看一下如何部署属于我们自己的域名。</p>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>首先，<code>域名</code>是需要花钱买的，我这里购买的是 <a href="https://cloud.tencent.com/act/domainsales?from=dnspodqcloud" target="_blank" rel="noopener">腾讯云域名购买</a>，你也可以到阿里云上面买，都可以，你开心就行。</p>
<p>进入到<strong>腾讯云</strong>，你应该会看到如下类似页面</p>
<p><img src="https://i.loli.net/2019/11/03/V28URtr6Bbn7SD1.png" alt="image0"></p>
<p>一般都选择<code>.com</code>，点击<code>购买</code>，然后会要求你登录、注册、实名认证等等，登录可以直接使用微信登录绑定，非常方便，按提示来就行。</p>
<p>接下来，输入你喜欢的域名（一般情况下，很多好的域名基本都被注册了），输入域名，会检测你当前输入的域名是否被注册，如果未注册，那么你就可以使用了，见下面：</p>
<p><img src="https://i.loli.net/2019/11/03/Uuc8dW2g1OCynJh.png" alt="image1"></p>
<p>下一步，付款，结束，这样你就拥有属于你自己的域名了。是不是购买结束，有了域名，一切就结束了呢？并不是，继续往下看。</p>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>到这里，你已经有了域名，但是，你的域名还是处于<code>未解析</code>和<code>域名所有者未认证（默认是注册者，但是要求你重新填写身份信息和联系地址、邮箱等等）</code>的，你可以根据提示进行操作，非常简单。</p>
<p>接着（我的是几分钟）域名审核通过后，你将需要将<code>你的域名</code>和<code>github博客地址</code>绑定起来。点击你域名，进入到如下图（下图是我已经关联<code>github博客</code>了）：</p>
<p><img src="https://i.loli.net/2019/11/03/1R7viVKWs5pl34d.png" alt="image2"></p>
<ul>
<li><p>1、 点击<code>添加记录</code></p>
</li>
<li><p>2、 主机记录选择<code>www</code></p>
</li>
<li><p>3、 记录类型选择<code>CNAME</code></p>
</li>
<li><p>4、 记录值选择<code>你的github博客域名</code></p>
</li>
</ul>
<p>ok，到这一步，你在<code>腾讯云</code>上面的操作基本结束了。</p>
<h2 id="hexo本地域名关联"><a href="#hexo本地域名关联" class="headerlink" title="hexo本地域名关联"></a>hexo本地域名关联</h2><ul>
<li>进入到你本地的<code>hexo根目录</code>下面的<code>source目录</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd source</span><br></pre></td></tr></table></figure>

<ul>
<li>创建<code>CNAME</code>文件（CNAME写死就行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi CNAME</span><br></pre></td></tr></table></figure>

<ul>
<li>添加你购买的域名</li>
</ul>
<p>比如我的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.clcoder.com</span><br></pre></td></tr></table></figure>

<ul>
<li><p>保存退出</p>
</li>
<li><p>重新部署博客</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>到这里，打开你的新域名，你就可以看到和你购买之前使用的类似<code>xxx.github.io</code>的个人博客了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h5 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h5><h5 id="2-平台（如腾讯云）关联域名"><a href="#2-平台（如腾讯云）关联域名" class="headerlink" title="2. 平台（如腾讯云）关联域名"></a>2. 平台（如腾讯云）关联域名</h5><h5 id="3-本地配置新域名并重新部署、发布hexo服务"><a href="#3-本地配置新域名并重新部署、发布hexo服务" class="headerlink" title="3. 本地配置新域名并重新部署、发布hexo服务"></a>3. 本地配置新域名并重新部署、发布hexo服务</h5><p>所有的一切，都刚刚好。</p>
]]></content>
      <categories>
        <category>Hexos</category>
      </categories>
      <tags>
        <tag>hexo, 域名</tag>
      </tags>
  </entry>
  <entry>
    <title>二 Python基础之字符串和编码</title>
    <url>/2019/10/28/%E4%BA%8C%20Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul>
<li>ASCII与Unicode的区别</li>
</ul>
<p><code>ASCII</code>编码是1个字节，而<code>Unicode</code>编码通常是2个字节。</p>
<ul>
<li>计算机系统通用的字符编码方式</li>
</ul>
<p>在计算机内存中，统一使用<code>Unicode</code>编码，当需要保存到<code>硬盘</code>或者需要传输的时候，就转换成<code>UTF-8</code>编码。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在<code>Python3</code>的字符串中，使用<code>Unicode</code>编码，也就是说，<code>Python</code>的字符串支持多语言。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;测试python字符串&apos;)</span><br><span class="line">测试python字符串</span><br></pre></td></tr></table></figure>

<p>对于单个字符的编码，<code>Python</code>提供了<code>ord()</code>函数获取<strong>字符的整数表示</strong>，<code>chr()</code>函数把编码转换成对应的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; chr(65)</span><br><span class="line">&apos;A&apos;</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(20013)</span><br><span class="line">&apos;中&apos;</span><br></pre></td></tr></table></figure>

<p>由于<code>Python</code>的字符串类型是<code>str</code>，在内存中以<code>Unicode</code>表示，一个字符对应若干个字节。如果要在网络上传输或者保存到磁盘上，就需要把<code>str</code>变成以<strong>字节为单位</strong>的<code>bytes</code>.</p>
<p><code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name = b&apos;ABC&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>虽然内容上一样，但是两者是有区别的，<code>&#39;ABC&#39;</code>是<code>str</code>，<code>b&#39;ABC&#39;</code>类型是<code>bytes</code>并且每个字符都只占用<strong>1个字节</strong>。</p>
</blockquote>
<h3 id="str编码为bytes"><a href="#str编码为bytes" class="headerlink" title="str编码为bytes"></a><code>str</code>编码为<code>bytes</code></h3><p>可以将<code>str</code>类型的字符串编码为指定的<code>bytes</code></p>
<ul>
<li>通过<code>ASCII</code>编码</li>
</ul>
<p>英文的字符串我们可以用过<code>ASCII</code>编码，但是中文是不允许的，因为超过了<code>ASCII</code>的编码范围。中文我们用<code>UTF-8</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;人民币&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe4\xba\xba\xe6\xb0\x91\xe5\xb8\x81&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在<code>bytes</code>中，如果无法显示成<code>ASCII</code>字符的字节，使用<code>\x##</code>表示。</p>
</blockquote>
<h3 id="bytes解码为str"><a href="#bytes解码为str" class="headerlink" title="bytes解码为str"></a><code>bytes</code>解码为<code>str</code></h3><p>我们从网络或磁盘上读取到的都是字节流<code>bytes</code>，因此我们需要<strong>解码</strong>为<code>str</code>，可以使用<code>decode</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xba\xba\xe6\xb0\x91\xe5\xb8\x81&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;人民币&apos;</span><br></pre></td></tr></table></figure>

<p>如果<code>bytes</code>中只有一小部分字节是无效的，那么可以传入<code>errors=&#39;ignore&#39;</code>来忽略错误的字节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xba\xba\xe6\xb0\x91\xe5\xb8\x81\xaa\xbb\xcc&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">&apos;人民币&apos;</span><br></pre></td></tr></table></figure>

<p>如果不使用<code>errors=&#39;ignore&#39;</code>，则会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xba\xba\xe6\xb0\x91\xe5\xb8\x81\xaa\xbb\xcc&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xaa in position 9: invalid start byte</span><br></pre></td></tr></table></figure>

<h3 id="计算字符数"><a href="#计算字符数" class="headerlink" title="计算字符数"></a>计算字符数</h3><p>可以使用<code>len()</code>函数来计算<code>str</code>的字符数，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;abc&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;我爱中国&apos;)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="计算字节数"><a href="#计算字节数" class="headerlink" title="计算字节数"></a>计算字节数</h3><p>如果需要计算一个<code>str</code>类型的<em>字节数</em>，需要先将<code>str</code>编码成为<code>bytes</code>，然后使用<code>len()</code>函数计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;abc&apos;.encode(&apos;ascii&apos;))</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;我爱中国&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，<code>1个中文</code>经过<code>UTF-8</code>编码后通常占用<code>3个字节</code>，<code>1个英文字符</code>只占用<code>1个字节</code>。</p>
<p>由于<code>Python</code>源代码本身也是一个<code>文本文件</code>，因此，为了保证使用的编码方式统一，防止含有中文导致乱码，以便<code>Python解释器</code>读取源文件是按照<code>UTF-8</code>的方式读取，最好在源文件头部加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>

<p>第一行注释是为了告诉<code>Linux/OS X</code>系统，这是一个<code>Python</code>可执行程序，<code>Windows</code>系统会忽略这个注释。</p>
<p>第二行注释是为了告诉<code>Python解释器</code>，按照<code>UTF-8</code>的方式读取源代码，否则如果源文件中含有<strong>中文</strong>的话可能会导致乱码。</p>
<blockquote>
<p>申明了<code>UTF-8编码</code>并不意味着你的<code>.py文件</code>就是<code>UTF-8编码</code>的，必须并且要确保文本编辑器正在使用<code>UTF-8 without BOM编码</code>; 如果<code>.py文件</code>本身使用<code>UTF-8编码</code>，并且也申明了<code># -*- coding: utf-8 -*-</code>，打开命令提示符测试就可以正常显示中文。</p>
</blockquote>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>常用格式化占位符如下表：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>整型</td>
</tr>
<tr>
<td>%f</td>
<td>浮点型</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody></table>
<ul>
<li>通用用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;am %s, I am %d years old, grade percentage is %s%%&apos; % (&apos;langke&apos;, 18, &apos;90&apos;))</span><br><span class="line">I&apos;am langke, I am 18 years old, grade percentage is 90%</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>format()</code>函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;我是&#123;0&#125;, 我今年的成绩提高了&#123;1:.2f&#125;%&apos;.format(&apos;刘德华&apos;, 16.394))</span><br><span class="line">我是刘德华, 我今年的成绩提高了16.39%</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前使用最多的编码方式是<code>UTF-8</code>，如果没有特别的业务要求，尽量使用<code>UTF-8</code>编码、解码，以避免乱码以及其他不必要的麻烦。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vim命令的基本使用</title>
    <url>/2019/10/27/vim%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文基于<code>Mac OS</code>环境，主要记录一些常用的<code>vim</code>配置和一些常用命令。</p>
<h3 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h3><ul>
<li>创建配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/.vimrc</span><br></pre></td></tr></table></figure>

<ul>
<li>显示行数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set number</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加到配置文件<code>.vimrc</code>中，重启终端即可生效。</p>
</blockquote>
<ul>
<li>tab缩进（按4个空格缩进）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set tabstop=4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加到配置文件<code>.vimrc</code>中，重启终端即可生效。</p>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>查看当前所在目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<ul>
<li>列举当前目录下所有文件及文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l</span><br></pre></td></tr></table></figure>

<ul>
<li>创建文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>创建并打开文件（如果文件已经存在，直接打开编辑）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>创建文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>删除空文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件夹（包括文件夹中的所有东西，慎用）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>查看文件内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat xxx</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less xxx</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>开始编辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<ul>
<li>保存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure>

<ul>
<li>退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure>

<ul>
<li>强制退出（不会保存所修改的内容）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q!</span><br></pre></td></tr></table></figure>

<ul>
<li>保存并退出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wq</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZZ</span><br></pre></td></tr></table></figure>

<ul>
<li>删除当前行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd</span><br></pre></td></tr></table></figure>

<ul>
<li>删除当前行以下多少行</li>
</ul>
<p>比如删除当前行往下<code>3</code>行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:3dd</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure>

<ul>
<li>移动文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv 源路径 目标路径</span><br></pre></td></tr></table></figure>

<p>如将<code>当前文件</code>移动到用户名录下的<code>DemoDir</code>文件夹中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv ./test.file ~/DemoDir</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 源路径 目标路径</span><br></pre></td></tr></table></figure>

<ul>
<li>光标跳到第几行</li>
</ul>
<p>比如跳到第<code>5</code>行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:5</span><br></pre></td></tr></table></figure>

<ul>
<li>光标左移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h</span><br></pre></td></tr></table></figure>

<ul>
<li>光标由移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l</span><br></pre></td></tr></table></figure>

<ul>
<li>光标上移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k</span><br></pre></td></tr></table></figure>

<ul>
<li>光标下移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j</span><br></pre></td></tr></table></figure>

<ul>
<li>在当前行下面插入空行并开始编辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o</span><br></pre></td></tr></table></figure>

<ul>
<li>在当前行上面插入空行并开始编辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O</span><br></pre></td></tr></table></figure>

<ul>
<li>在当前行头部开始编辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I</span><br></pre></td></tr></table></figure>

<ul>
<li>在当前行末开始编辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>

<ul>
<li>复制当前行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yy</span><br></pre></td></tr></table></figure>

<ul>
<li>粘贴到当前行下面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p</span><br></pre></td></tr></table></figure>

<ul>
<li>粘贴到当前行上面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P</span><br></pre></td></tr></table></figure>

<ul>
<li>从当前行往下复制n行(n为数字)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nyy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>vim, 命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>一 Python基础之数据类型和变量</title>
    <url>/2019/10/27/%E4%B8%80%20Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文基于<code>Python 3.7.4</code>环境下运行。</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><code>Python</code>可以处理<strong>任意大小</strong>的整数，这就表示在我们使用的过程中，不会出现<strong>数据溢出</strong>的情况，这一点也极大地方便了<code>Python</code>的开发者。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><code>浮点数</code>就是<code>小数</code>，只是<strong>过大</strong>、<strong>过小</strong>或<strong>某些情况下</strong>的<code>浮点数</code>我们会采用<code>科学计数法</code>来表示，比如：3.88e9、38.8e8。</p>
<p>注意：<code>浮点数</code>和<code>整数</code>的在计算机中的存储方式不一样，<code>整数</code>一定是<strong>精确的</strong>，而<code>浮点数</code>可能会有四舍五入的误差。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>Python</code>的<code>字符串</code>可以用<code>单引号&#39;&#39;</code>或者<code>双引号&quot;&quot;</code>括起来，但是必须<code>成对使用</code>，不能<code>单引号</code>和<code>双引号</code>混用，否则会<strong>报错</strong>。</p>
<p>如果需要在字符串内使用特殊字符，比如<code>单引号&#39;&#39;</code>或者<code>双引号&quot;&quot;</code>等，可以使用<code>反斜杠\</code>进行转译。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&apos;The world\&apos;s beautiful!&apos;)</span><br></pre></td></tr></table></figure>

<p>对应输出的内容是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The world&apos;s beautiful!</span><br></pre></td></tr></table></figure>

<p>当然，如果不想转义呢？这时，<code>Python</code>给我们提供了<code>r</code>前缀代表字符串内的所有字符不需要转义。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(r&apos;The world\&apos;s beautiful!&apos;)</span><br></pre></td></tr></table></figure>

<p>对应输出的内容是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The world\&apos;s beautiful!</span><br></pre></td></tr></table></figure>

<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>Python</code>的<code>布尔值</code>用<code>True</code>和<code>False</code>来表示。</p>
<p>与<code>布尔值</code>常搭配使用的还有<code>逻辑运算符</code>：<code>or(或)</code>、<code>and(与)</code>、<code>not(非)</code>。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; True or False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p><code>Python</code>提供了<code>空值</code>，用<code>None</code>表示，它的类型是<code>NoneType</code>。</p>
<p>可以使用<code>Python</code>的内置函数<code>type()</code>函数查看其类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(None)</span><br><span class="line">&lt;class &apos;NoneType&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>注意：<code>None</code>和<code>0</code>是有区别的，<code>0</code>是有意义的，<code>None</code>是一个特殊的<code>空值</code>。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>Python</code>中的<code>变量</code>很简单，不需要声明其什么类型，直接使用，并且必须是`数字、大小写英文字母、下划线_的组合。</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name = &apos;Alice&apos;</span><br><span class="line"></span><br><span class="line">age = 18</span><br><span class="line"></span><br><span class="line">isGirl = True</span><br></pre></td></tr></table></figure>

<p><code>name</code>是一个<code>字符串类型</code>的<code>变量</code>。</p>
<p><code>age</code>是一个<code>整型</code>的<code>变量</code>。</p>
<p><code>isGirl</code>是一个<code>布尔类型</code>的<code>变量</code>。</p>
<p><code>Python</code>的<code>变量类型</code>是<strong>不固定的</strong>，意味着</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value = &apos;Alice&apos;</span><br><span class="line">value = 666</span><br></pre></td></tr></table></figure>

<p>以上，我们可以创建了一个<code>字符串类型</code>的<code>变量value</code>，接着，我们又给其赋值一个<code>整型类型</code>的值<code>666</code>，这样是否可以呢？答案：是。因为<code>Python</code>是<code>动态语言</code>，也就是说，变量本身类型是不固定的，你可以把<code>字符串</code>赋值给<code>整型</code>的<code>变量</code>，也可以把<code>整型值</code>赋值给<code>字符串类型</code>的<code>变量</code>。</p>
<p>有<code>动态语言</code>，就意味着有<code>静态语言</code>，比如<code>Java</code>、<code>Swift</code>等等。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>顾名思义，<code>常量</code>就是<strong>不能改变的变量</strong>，但是，在<code>Python</code>中，是没有<code>常量</code>这一精确概念的，通常来说，我们会用<em>全部大写</em>的方式来<em>表示常量</em>，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AGE = 18</span><br><span class="line">PI = 3.14</span><br></pre></td></tr></table></figure>

<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul>
<li>正常的除法 <code>/</code></li>
</ul>
<p>使用<code>/</code>做除法，结果永远是浮点数。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br><span class="line">&gt;&gt;&gt; 4 / 2</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>

<ul>
<li>地板除 <code>//</code></li>
</ul>
<p>结果永远是<code>整数</code>。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<ul>
<li>取余 <code>%</code></li>
</ul>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 % 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Python</code>的基本数据类型及变量比较灵活，使用的时候要注意一些与其他语言不同的地方，如<code>地板除</code>、<code>通用除法的结果是浮点数</code>并且<code>变量</code>是<code>动态的</code>。<code>Python</code>是一门<code>动态类型语言</code>，当然，也是一门<code>解释型</code>、<code>通用型</code>、<code>高级</code>编程语言。</p>
<hr>
<p>学习资料来源：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017063826246112" target="_blank" rel="noopener">廖雪峰的官方网站</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的基本使用</title>
    <url>/2019/09/23/Hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;博客标题&quot;</span><br></pre></td></tr></table></figure>

<h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>先清理缓存，一般可能会由于本地缓存而导致发布没有生效（可选）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>发布和部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令其实和：1. <code>hexo g</code>，2. <code>hexo d</code> 是一样的。</p>
</blockquote>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>推荐人气最佳的<code>next</code>主题，其他更换主题的方式都差不多的</p>
<ul>
<li>1.安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<ul>
<li>2.修改</li>
</ul>
<p>打开根目录下配置文件<code>_config.yml</code>, 找到<code>theme</code>项，修改为以下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><h3 id="一-修改主题布局"><a href="#一-修改主题布局" class="headerlink" title="一 修改主题布局"></a>一 修改主题布局</h3><p>在根目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi themes/next/_config.yml</span><br></pre></td></tr></table></figure>

<p>找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>根据自己需要，打开相应的<code>scheme</code>项，即可浏览相应的效果。我比较喜欢<code>scheme: Pisces</code>，左侧是栏目，右侧显示内容。</p>
<h3 id="二-增加标签和分类"><a href="#二-增加标签和分类" class="headerlink" title="二 增加标签和分类"></a>二 增加<code>标签和分类</code></h3><p>在根目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi themes/next/_config.yml</span><br></pre></td></tr></table></figure>

<p>找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<p>打开主题配置文件里面的<code>menu项</code>，接着打开相应的子配置项<code>tags</code>和<code>categories</code>。</p>
<h4 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h4><ul>
<li>2.1.1 新建一个页面，命名为 <code>categories</code> 。命令如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<ul>
<li>2.1.2 编辑刚新建的页面，将页面的类型设置为 <code>categories</code> ，主题将自动为这个页面显示所有分类。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2019-10-07 21:27:11</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ul>
<li>2.1.3 关联博客</li>
</ul>
<p>在文章头部，添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: iOS</span><br></pre></td></tr></table></figure>

<p>这样就关联到了<code>iOS</code>分类了。</p>
<ul>
<li>2.1.4 二级分类</li>
</ul>
<p>有时候可能需要添加二级分类，比如<code>iOS</code>下面有<code>Swift</code>和<code>Objective-C</code>， 那么二级分类也很简单，直接在文章的头部的分类中依次添加一级分类、二级分类。比如</p>
<p><code>iOS</code>分类下有一个<code>Swift</code>分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello, swift!</span><br><span class="line">date: 2019-11-04 20:01:18</span><br><span class="line">categories: </span><br><span class="line">- iOS</span><br><span class="line">- Swift</span><br><span class="line">tags: Swift</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><code>iOS</code>分类下再有一个<code>Objective-C</code>分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello, Objective-C!</span><br><span class="line">date: 2019-11-04 20:01:18</span><br><span class="line">categories: </span><br><span class="line">- iOS</span><br><span class="line">- Objective-C</span><br><span class="line">tags: OC</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="2-2-标签"><a href="#2-2-标签" class="headerlink" title="2.2 标签"></a>2.2 标签</h4><ul>
<li>2.2.1 新建一个页面，命名为<code>tags</code> 。命令如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.2.2 编辑刚新建的页面，将页面的类型设置为 <code>tags</code> ，主题将自动为这个页面显示标签云。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2019-10-07 21:27:11</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="三-添加头像"><a href="#三-添加头像" class="headerlink" title="三 添加头像"></a>三 添加头像</h3><p>编辑主题的 <code>_config.yml</code>，新增字段<code>avatar</code>， 值设置成头像的链接地址。</p>
<p>其中，头像的链接地址可以是：<br>    1    完整的互联网 <code>URL</code>，例如：<code>https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</code><br>    2    站点内的地址，例如：<br>    ◦    <code>/uploads/avatar.jpg</code> 需要将你的头像图片放置在 站点的 <code>source/uploads/</code>（可能需要新建uploads目录）<br>    ◦    <code>/images/avatar.jpg</code> 需要将你的头像图片放置在 主题的 <code>source/images/</code> 目录下。</p>
<p>在根目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi themes/next/_config.yml</span><br></pre></td></tr></table></figure>

<p>找到并打开<code>avatar: /images/avatar.jpg</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.gif</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">avatar: /images/avatar.jpg</span><br></pre></td></tr></table></figure>

<h3 id="四-文章截断"><a href="#四-文章截断" class="headerlink" title="四 文章截断"></a>四 文章截断</h3><p>在<code>themes/next/_config.yml</code>下开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<h3 id="五-添加文章阅读次数"><a href="#五-添加文章阅读次数" class="headerlink" title="五 添加文章阅读次数"></a>五 添加文章阅读次数</h3><p>详细请查看：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">添加文章阅读次数</a> ，若访问出现问题，查看：<a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">Leancloud访客统计插件重大安全漏洞修复指南</a>。</p>
<blockquote>
<p>提示：在部署插件过程中或在<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud官网</a>注册的时候，要把账号密码记下来，比如我就是放在手机的备忘录中，不然后期部署可能会有麻烦。</p>
</blockquote>
<h3 id="五-添加本地搜索"><a href="#五-添加本地搜索" class="headerlink" title="五 添加本地搜索"></a>五 添加本地搜索</h3><p>添加百度/谷歌/本地 自定义站点内容搜索</p>
<ul>
<li>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑 <code>站点配置文件</code>，新增以下内容到任意位置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑 <code>主题配置文件</code>，启用本地搜索功能：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>更多可以查看：<a href="http://theme-next.iissnan.com/third-party-services.html#share-system" target="_blank" rel="noopener">第三方服务</a></p>
<p>本文已涉及或未涉及的配置详情可见：<a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="noopener">hexo-theme-next主题在github的使用配置文档说明</a></p>
]]></content>
      <categories>
        <category>Hexos</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/2019/09/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexos</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins + Fastlane + 蒲公英 + iOS + Android打包</title>
    <url>/2019/09/23/Jenkins-Fastlane-%E8%92%B2%E5%85%AC%E8%8B%B1-iOS-Android%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本教程结合<code>Jenkins</code>、<code>Fastlane</code>和<code>蒲公英</code>对<code>iOS</code>和<code>Android</code>实现自动化打包并上传蒲公英，详细说明了打包的<code>jenkins配置</code>、<code>fastlane脚本配置</code>并上传到蒲公英。然而，针对安装<code>jenkins</code>并没有详细的大量篇幅说明，若安装<code>jenkins</code>出现问题，可自行<code>Google</code>或<code>去官方网站</code>查询，资料很多，这里并不一一列举。</p>
<h2 id="二-环境"><a href="#二-环境" class="headerlink" title="二 环境"></a>二 环境</h2><p>本文主要针对<code>React Native</code>项目对<code>iOS</code>和<code>Android</code>进行打包，笔者也亲自实践过原生项目的打包，除了路径不一样，其余都是一模一样的。</p>
<p>环境如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React Native Environment Info:</span><br><span class="line">    System:</span><br><span class="line">      OS: macOS 10.14.5</span><br><span class="line">      CPU: (4) x64 Intel(R) Core(TM) i3-8100B CPU @ 3.60GHz</span><br><span class="line">      Memory: 166.11 MB / 8.00 GB</span><br><span class="line">      Shell: 5.3 - /bin/zsh</span><br><span class="line">    Binaries:</span><br><span class="line">      Node: 11.5.0 - /usr/local/bin/node</span><br><span class="line">      Yarn: 1.17.3 - ~/.yarn/bin/yarn</span><br><span class="line">      npm: 6.4.1 - /usr/local/bin/npm</span><br><span class="line">      Watchman: 4.9.0 - /usr/local/bin/watchman</span><br><span class="line">    SDKs:</span><br><span class="line">      iOS SDK:</span><br><span class="line">        Platforms: iOS 12.2, macOS 10.14, tvOS 12.2, watchOS 5.2</span><br><span class="line">      Android SDK:</span><br><span class="line">        API Levels: 23, 26, 27, 28</span><br><span class="line">        Build Tools: 23.0.1, 26.0.1, 27.0.3, 28.0.2, 28.0.3</span><br><span class="line">        System Images: android-23 | Intel x86 Atom_64, android-23 | Google APIs Intel x86 Atom, android-23 | Google APIs Intel x86 Atom_64, android-27 | Intel x86 Atom_64, android-27 | Google APIs Intel x86 Atom, android-27 | Google Play Intel x86 Atom</span><br><span class="line">    IDEs:</span><br><span class="line">      Android Studio: 3.3 AI-182.5107.16.33.5314842</span><br><span class="line">      Xcode: 10.2.1/10E1001 - /usr/bin/xcodebuild</span><br><span class="line">    npmPackages:</span><br><span class="line">      react: ^16.6.0-alpha.8af6728 =&gt; 16.6.0-alpha.8af6728</span><br><span class="line">      react-native: 0.57.4 =&gt; 0.57.4</span><br><span class="line">    npmGlobalPackages:</span><br><span class="line">      react-native-cli: 2.0.1</span><br><span class="line">      react-native-update-cli: 0.1.0</span><br></pre></td></tr></table></figure>

<h2 id="三-安装"><a href="#三-安装" class="headerlink" title="三 安装"></a>三 安装</h2><h4 id="3-1-安装Jenkins"><a href="#3-1-安装Jenkins" class="headerlink" title="3.1 安装Jenkins"></a>3.1 安装<code>Jenkins</code></h4><ul>
<li>3.1.1 升级ruby</li>
</ul>
<blockquote>
<p>由于<code>fastlane</code>依赖<code>ruby环境</code>，默认情况下，<code>Mac</code>下得<code>ruby</code>或者版本比较低，这取决于你的系统，但是建议对其进行升级到最新版本，以免后续出错。</p>
</blockquote>
<p><em>3.1.1.1 查看当前<code>ruby</code>版本：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure>

<p><em>3.1.1.2 安装<code>rvm</code>(Ruby Version Manager)</em></p>
<p><strong>注：</strong><a href="https://docs.fastlane.tools/best-practices/continuous-integration/jenkins/" target="_blank" rel="noopener">fastlane官方建议</a>使用<a href="https://github.com/rbenv/rbenv" target="_blank" rel="noopener">rbenv</a>来安装和管理<code>ruby</code>。事实上，使用<code>rvm</code>已经足够，取决于个人的选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\curl -sSL https://get.rvm.io | bash -s stable --ruby</span><br></pre></td></tr></table></figure>

<p><em>3.1.1.3 退出终端，重新打开，查看是否安装成功</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rvm -v</span><br></pre></td></tr></table></figure>

<p><em>3.1.1.4 列举出ruby所有版本</em> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rvm list known</span><br></pre></td></tr></table></figure>

<p><em>3.1.1.5 升级ruby</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rvm install 版本号 // 注意：这个版本号是你刚才列举出来的ruby所有版本号之一，一般选择最新的即可</span><br></pre></td></tr></table></figure>

<ul>
<li>3.1.2 安装<code>Jenkins</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew install jenkins</span><br></pre></td></tr></table></figure>

<p>若遇到问题，请查看<a href="https://jenkins.io/zh/doc/book/installing/" target="_blank" rel="noopener">Jenkins官网</a> 或 自行<code>Google</code>。</p>
<blockquote>
<p>注：不推荐直接下载<code>pkg</code>包直接安装。</p>
</blockquote>
<h4 id="3-2-安装xcode打包所需命令行工具"><a href="#3-2-安装xcode打包所需命令行工具" class="headerlink" title="3.2 安装xcode打包所需命令行工具"></a>3.2 安装<code>xcode</code>打包所需命令行工具</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h4 id="3-3-安装fastlane"><a href="#3-3-安装fastlane" class="headerlink" title="3.3 安装fastlane"></a>3.3 安装<code>fastlane</code></h4><ul>
<li>方式一，使用<code>Homebrew</code>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install fastlane</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二， 使用<code>RubyGems</code>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install fastlane -NV</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于方式二，若遇到无执行权限，可尝试：<code>sudo gem install fastlane -NV</code>。</p>
</blockquote>
<h4 id="3-4-设置环境变量"><a href="#3-4-设置环境变量" class="headerlink" title="3.4 设置环境变量"></a>3.4 设置环境变量</h4><p>将一下命令添加到你的<code>~/.bashrc</code>, <code>~/.bash_profile</code>, <code>~/.profile</code> 或者 <code>~/.zshrc</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LC_ALL=en_US.UTF-8</span><br><span class="line">export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：添加的目的是保证<code>fastlane</code>能够在<code>utf-8</code>编码环境下执行，否则在未设置<code>utf-8</code>为默认编码的系统上，<code>fastlane</code>运行可能会出现错误❌。</p>
</blockquote>
<p>接着使其生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果你是添加到<code>~/.bashrc</code>中，就使用<code>source ~/.bashrc</code>; 若你是添加到<code>~/.bash_profile</code>中，就使用<code>source ~/.bash_profile</code>，以此类推。</p>
</blockquote>
<h2 id="四-初始化"><a href="#四-初始化" class="headerlink" title="四 初始化"></a>四 初始化</h2><h4 id="4-1-使用Gemfile-可选，但是建议安装"><a href="#4-1-使用Gemfile-可选，但是建议安装" class="headerlink" title="4.1 使用Gemfile(可选，但是建议安装)"></a>4.1 使用<code>Gemfile</code>(可选，但是建议安装)</h4><blockquote>
<p>注：这只是<code>fastlane</code>官方推荐，原因如果我们使用<code>Gemfile</code>文件的话，我们可以使用它来定义<code>fastlane</code>的相关依赖，其次这也可以让我们现在所使用到的<code>fastlane</code>版本一目了然，并且还可以加快<code>fastlane</code>命令的执行，这<strong>不是必须的步骤！！！</strong></p>
</blockquote>
<ul>
<li>4.1.1 在工程根目录下（xxx.xcodeproj所在目录）创建<code>Gemfile</code></li>
</ul>
<blockquote>
<p>（一般是根目录，如果是<code>React Native</code>项目，则在<code>ios</code>目录下， <code>Android</code>的话进入<code>.../android</code>目录下， <code>Android</code>没有<code>scheme.xcodeproj</code>）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch Gemfile</span><br></pre></td></tr></table></figure>

<ul>
<li>4.1.2 将以下内容添加到刚才创建的<code>Gemfile</code>文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &quot;https://rubygems.org&quot;</span><br><span class="line"></span><br><span class="line">gem &quot;fastlane&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.1.3 安装<code>bundle</code>命令</li>
</ul>
<p>请依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle install</span><br><span class="line"></span><br><span class="line">bundle update</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注1：如果以上执行没有权限，请在前面添加 <code>sudo</code> 命令。以上会生成 <code>Gemfile</code> 和 <code>Gemfile.lock</code> 文件，可以提交到版本控制系统<code>git</code>中。</p>
</blockquote>
<blockquote>
<p>注2：后面执行<code>fastlane</code>命令的时候，我们就可以使用 <code>bundle exec fastlane [lane]</code>， 后面的 <code>[lane]</code> 代表你在<code>Fastfile</code>文件里面配置的<code>lane项</code>，比如：<code>bundle exec fastlane topgyer</code>命令中的<code>toppgyer</code>。</p>
</blockquote>
<blockquote>
<p>注3: 如果要更新<code>fastlane</code>，也可以使用: <code>[sudo] bundle update fastlane</code>命令。</p>
</blockquote>
<h4 id="4-2-初始化fastlane"><a href="#4-2-初始化fastlane" class="headerlink" title="4.2 初始化fastlane"></a>4.2 初始化<code>fastlane</code></h4><blockquote>
<p><code>cd</code>到 <code>scheme.xcodeproj</code>所在目录（一般是根目录，如果是<code>React Native</code>项目，则在<code>ios</code>目录下， <code>Android</code>的话进入<code>.../android</code>目录下， <code>Android</code>没有<code>scheme.xcodeproj</code>）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane init</span><br></pre></td></tr></table></figure>

<p>出现：<code>What would you like to use fastlane for?</code></p>
<p>答：4</p>
<blockquote>
<p>根据提示选择相应的提示项，一路往下走即可。</p>
</blockquote>
<h2 id="五-添加插件"><a href="#五-添加插件" class="headerlink" title="五 添加插件"></a>五 添加插件</h2><p>这里我们添加的是<code>蒲公英</code>插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane add_plugin pgyer</span><br></pre></td></tr></table></figure>

<h2 id="六-修改配置"><a href="#六-修改配置" class="headerlink" title="六 修改配置"></a>六 修改配置</h2><h4 id="6-1-iOS"><a href="#6-1-iOS" class="headerlink" title="6.1 iOS"></a>6.1 iOS</h4><p><code>cd</code>到<code>ios/fastlane</code>目录下，修改<code>Fastfile</code>文件，替换所有内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打包平台</span><br><span class="line">default_platform(:ios)</span><br><span class="line"></span><br><span class="line">platform :ios do</span><br><span class="line">desc &quot;上传ad-hoc的ipa包到蒲公英平台&quot; </span><br><span class="line"></span><br><span class="line">  lane :UploadToPgyer do|option|</span><br><span class="line">    # 自动增加Build</span><br><span class="line">    increment_build_number</span><br><span class="line">    </span><br><span class="line">    # ❣️编译的scheme，也就是 “xxx.xcodeproj” 中的 “xxx”(必须一致！！！)</span><br><span class="line">    scheme_name = &quot;工程名&quot;</span><br><span class="line"></span><br><span class="line">    # 获取项目中的 Version 和 Build</span><br><span class="line">    version = get_info_plist_value(path: &quot;./#&#123;scheme_name&#125;/Info.plist&quot;, key: &quot;CFBundleShortVersionString&quot;)</span><br><span class="line">    build = get_info_plist_value(path: &quot;./#&#123;scheme_name&#125;/Info.plist&quot;, key: &quot;CFBundleVersion&quot;)</span><br><span class="line">    </span><br><span class="line">    # 导出ipa包路径（这里放在当前所在的build目录下，打包成功后，ipa包就可以在这里找到哦）</span><br><span class="line">    output_directory = &quot;./build&quot;</span><br><span class="line">    </span><br><span class="line">    # 导出ipa的名称：例如（wanke_1.0.0_5_20190910111549.ipa），也可以写死，这是灵活的，取决于你的需要。</span><br><span class="line">    # ① wanke：这是你的工程名；1.0.0：这是你的版本号（取决于你在xcode中的设置）</span><br><span class="line">    # ② 20190910111549：这是详细时间，形式为：年-月-日-小时-分钟-秒。代表的是你本次打包的时间。</span><br><span class="line">    output_name = &quot;#&#123;scheme_name&#125;_#&#123;version&#125;_#&#123;build&#125;_#&#123;Time.now.strftime(&apos;%Y%m%d%H%M%S&apos;)&#125;.ipa&quot;</span><br><span class="line"></span><br><span class="line">    # 打包时输出提示，可随便修改，或者不要都行</span><br><span class="line">    puts &quot;-----开始打包-----&quot;</span><br><span class="line">    </span><br><span class="line">    gym(</span><br><span class="line">      export_method: &quot;ad-hoc&quot;,  # 导出方式：ad-hoc（测试包）、app-store（上传到App Store包）、enterprise（企业测试包）</span><br><span class="line">      export_xcargs: &quot;-allowProvisioningUpdates&quot;,</span><br><span class="line">      export_options:&#123;</span><br><span class="line">         provisioningProfiles: &#123;</span><br><span class="line">            &quot;cn.com.kkk&quot; =&gt; &quot;iPhone Distribution: kkk. (77777XXRRR)&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      scheme: scheme_name,</span><br><span class="line">      clean: true, # 每次打包都清空上一次的编译信息</span><br><span class="line">      output_directory: output_directory,</span><br><span class="line">      output_name: output_name</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    # 打包时输出提示，可随便修改，或者不要都行</span><br><span class="line">    puts &quot;-----开始上传到蒲公英平台-----&quot;</span><br><span class="line">    </span><br><span class="line">    # ❣️蒲公英平台的 API Key 和 User Key（直接复制过来即可）</span><br><span class="line">    pgyer(api_key: &quot;蒲公英API Key&quot;, user_key: &quot;蒲公英User Key&quot;)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<blockquote>
<p>iOS注意：<code>Fastfile</code>文件中加❣️的地方为必填项，其他地方基本不用改动即可直接打包，如果想自己改动或添加其他参数也可以，自行<code>Google</code>或去官方查看命令！！！</p>
</blockquote>
<h4 id="6-2-Android"><a href="#6-2-Android" class="headerlink" title="6.2 Android"></a>6.2 Android</h4><p><code>cd</code>到<code>anddroid/fastlane</code>目录下，修改<code>Fastfile</code>文件，替换所有内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_platform(:android)</span><br><span class="line"></span><br><span class="line">platform :android do</span><br><span class="line">  desc &quot;上传android的apk包到蒲公英平台&quot;</span><br><span class="line">  lane :UploadToPgyer do</span><br><span class="line">     gradle(task: &apos;clean&apos;)</span><br><span class="line">     gradle(task: &quot;assembleRelease&quot;)</span><br><span class="line">    # ❣️蒲公英平台的 API Key 和 User Key（直接复制过来即可）</span><br><span class="line">    pgyer(api_key: &quot;蒲公英API Key&quot;, user_key: &quot;蒲公英User Key&quot;)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Android注意：<code>Fastfile</code>文件中加❣️的地方为必填项，其他地方基本不用改动即可直接打包，如果想自己改动或添加其他参数也可以，自行<code>Google</code>或去官方查看命令！！！</p>
</blockquote>
<h2 id="七-打包上传"><a href="#七-打包上传" class="headerlink" title="七 打包上传"></a>七 打包上传</h2><h4 id="7-1-本地直接打包"><a href="#7-1-本地直接打包" class="headerlink" title="7.1 本地直接打包"></a>7.1 本地直接打包</h4><blockquote>
<p>（一般是根目录，如果是<code>React Native</code>项目，则在<code>ios</code>目录下， <code>Android</code>的话进入<code>.../android</code>目录下， <code>Android</code>没有<code>scheme.xcodeproj</code>）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane UploadToPgyer</span><br></pre></td></tr></table></figure>

<h4 id="7-2-使用Jenkins打包"><a href="#7-2-使用Jenkins打包" class="headerlink" title="7.2 使用Jenkins打包"></a>7.2 使用<code>Jenkins</code>打包</h4><blockquote>
<p>说明：在使用<code>Jenkins</code>打包之前，请先尝试<code>7.1</code>能够在本地打包成功，因为<code>Jenkins</code>只是一个工具，最终执行还是本地<code>fastfile</code>文件中的脚本，若本地打包失败，意味着你在<code>jenkins</code>上配置出来打包必然失败。</p>
</blockquote>
<p><code>jenkins</code>安装好后，配置以及创建项目这里就直接忽略，有问题自行<code>Google</code>。接下来直接进入配置项。</p>
<ul>
<li><strong>7.2.1 <code>general</code></strong></li>
</ul>
<p><img src="https://i.loli.net/2019/09/12/d6vytZ87IHOgPVw.png" alt="1241568256881_.pic_好的.jpg"></p>
<ul>
<li><strong>7.2.2 源码管理</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/09/11/C6JfdemONPYoRHA.png" alt="496131568186987_.pic_好的.jpg"></p>
<ul>
<li><p><strong>7.2.3 构建触发器（不需要，可跳过）</strong></p>
</li>
<li><p><strong>7.2.4 构建环境</strong></p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/09/11/eKa54XmDkqhGrxM.png" alt="496141568187214_.pic.jpg"></p>
<ul>
<li><strong>7.2.5 构建</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/09/12/28EUzOMVWySrqQu.png" alt="1251568258617_.pic_好的.jpg"></p>
<p><code>shell脚本</code>如下（可直接复制粘贴使用，需要修改的地方以下有说明）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使环境变量配置生效</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">case $Platform in</span><br><span class="line">    iOS)</span><br><span class="line">         echo &quot;❣️开始iOS打包，成功后自动上传到蒲公英&quot;</span><br><span class="line">         # 解锁Mac上的钥匙串（123456789是你自己的开机密码），LiuDeHua是你自己的用户名，可用pwd命令查看</span><br><span class="line">		 security unlock-keychain -p 123456789 /Users/LiuDeHua/Library/Keychains/login.keychain</span><br><span class="line">		 # 这个目录就是jenkins拉取的工程所在的目录，只有这个目录下可以打包</span><br><span class="line">		 cd /Users/LiuDeHua/jenkins/workspace/CIProject/JenkinsDemo/ios</span><br><span class="line">		 # 这里主要是为了移除上一次打的ipa包，留着没用，你也可以选择保留   </span><br><span class="line">		 #（注：由于我在Fastlane文件导出的包名与打包时间相关，每次都不一样，所以每打一次就会不断增加ipa包）     </span><br><span class="line">		 rm -rf /Users/LiuDeHua/jenkins/workspace/CIProject/JenkinsDemo/ios/build</span><br><span class="line">    ;;</span><br><span class="line">    Android)</span><br><span class="line">         echo &quot;❣️开始Android打包，成功后自动上传到蒲公英&quot;</span><br><span class="line">         # 这个目录就是jenkins拉取的工程所在的目录，只有这个目录下可以打包</span><br><span class="line">		 cd /Users/langke/jenkins/workspace/CIProject/JenkinsDemo/android</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">    	echo &quot;❌Arguments error! Please check your shell script!!!&quot;</span><br><span class="line">    	exit</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># 更新bundle命令（fastlane官方建议的），如果没使用bundle，这一行直接去掉</span><br><span class="line">/usr/local/bin/bundle update</span><br><span class="line"># 打包本地的fastlane脚本，如果没使用bundle，去掉/usr/local/bin/bundle exec即可 </span><br><span class="line">/usr/local/bin/bundle exec fastlane UploadToPgyer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 注意：以上的路径，比如 `/Users/LiuDeHua/jenkins/workspace/CIProject/JenkinsDemo/ios` 都可以自己利用`terminal`进入到你的工程根目录下，然后使用 `pwd` 命令查看并复制粘贴即可，每个人的用户名、项目名一般都不一样，因此路径也不一样，但原理都是一样的。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>7.2.6 构建后操作（不需要，可跳过）</strong></li>
</ul>
<h2 id="八-Jenkins打包报错"><a href="#八-Jenkins打包报错" class="headerlink" title="八 Jenkins打包报错"></a>八 Jenkins打包报错</h2><ul>
<li>❌  <code>(iOS)</code>  error: Can’t find ‘node’ binary to build React Native bundle</li>
</ul>
<blockquote>
<p>这个报错一般针对<code>React Native</code>工程，原生项目不会。</p>
</blockquote>
<p>✅ 打开<code>xcode</code>, <code>Build Phases</code> -&gt; <code>Bundle React Native code and images</code></p>
<p>里面的脚本默认看起来是下面这个样子👇</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NODE_BINARY=/usr/local/bin/node</span><br><span class="line">../node_modules/react-native/scripts/react-native-xcode.sh</span><br></pre></td></tr></table></figure>

<p>在<code>terminal</code>上输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which node</span><br></pre></td></tr></table></figure>

<p>比如我电脑上💻的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node</span><br></pre></td></tr></table></figure>

<p>将<code>/usr/local/bin/node</code>替换脚本中的<code>node</code>即可，即最终结果看起来如下👇：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NODE_BINARY=node</span><br><span class="line">../node_modules/react-native/scripts/react-native-xcode.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>❌ ❌ <code>Android</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"> </span><br><span class="line">What went wrong:</span><br><span class="line">Execution failed for task &apos;:app:bundleReleaseJsAndAssets&apos;.</span><br><span class="line">A problem occurred starting process &apos;command &apos;node&apos;&apos;</span><br></pre></td></tr></table></figure>

<p>✅✅ 本地进入到项目的 <code>./android</code>目录下，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./gradlew --stop</span><br></pre></td></tr></table></figure>

<p>答案源自: <a href="https://github.com/facebook/react-native/issues/6875#issuecomment-215854946" target="_blank" rel="noopener">github</a></p>
<p>然后重新尝试打包，应该就<code>OK</code>了。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>jenkins, fastlane, iOS, Android, 自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift自动布局SnapKit的详细使用介绍</title>
    <url>/2017/04/27/Swift%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80SnapKit%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SnapKit，一个经典的<strong>Swift</strong>版的第三方库，专门用于项目的自动布局，目前在github上的<strong>stars</strong>就高达9340颗星，这是一个不小的数字，亦足以证明它存在的非凡意义和作用。作者认为，在iOS开发（swift）中，它是用于项目最优秀的自动布局的必选库之一。它的作者仍然是写Objective-C的第三方库Masonry的大牛 - <strong>@Robert Payne</strong>，开门见山，本文将详细介绍介绍<strong>SnapKit</strong>的详细使用和安装，相信对于初入门该库的开发者或许会有一定的帮助，当然，鉴于作者能力有限，如有不足之处，欢迎指点和批评。也可以通过加作者创建的iOS(Swift)开发互助群交流和学习，群号QQ：558179558。</p>
<h3 id="Snapkit的安装（CocoaPods"><a href="#Snapkit的安装（CocoaPods" class="headerlink" title="Snapkit的安装（CocoaPods)"></a>Snapkit的安装（CocoaPods)</h3><h4 id="环境配置要求："><a href="#环境配置要求：" class="headerlink" title="环境配置要求："></a>环境配置要求：</h4><ul>
<li><p>iOS 8.0 / Mac OS X 10.11+ </p>
</li>
<li><p>Xcode 8.0+</p>
</li>
<li><p>Swift 3.0+</p>
</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在已经安装CocoaPods的前提下， 即可以进行下列步骤。</p>
<ul>
<li>在你的项目工程里的<strong>Podfile</strong>文件里面添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"></span><br><span class="line">platform :ios, &apos;10.0&apos;</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &apos;这里是你的工程名称&apos; do</span><br><span class="line">    pod &apos;SnapKit&apos;, &apos;~&gt; 3.0&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>老生常谈，运行CocoaPods的如下命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>

<p>到此，不出意外的话，你已经将<strong>SnapKit</strong>集成到你的项目中了。然后，就开始讲怎么使用它了。</p>
<h3 id="Snapkit的布局使用"><a href="#Snapkit的布局使用" class="headerlink" title="Snapkit的布局使用"></a>Snapkit的布局使用</h3><p><strong>1</strong>、 实现一个宽高为100，居于当前视图的中心的视图布局，示例代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">     </span><br><span class="line">        let testView = UIView()</span><br><span class="line">        testView.backgroundColor = UIColor.cyan</span><br><span class="line">        view.addSubview(testView)</span><br><span class="line">        testView.snp.makeConstraints &#123; (make) in</span><br><span class="line">            make.width.equalTo(100)         // 宽为100</span><br><span class="line">            make.height.equalTo(100)        // 高为100</span><br><span class="line">            make.center.equalTo(view)       // 位于当前视图的中心</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简洁的写法可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">     </span><br><span class="line">        let testView = UIView()</span><br><span class="line">        testView.backgroundColor = UIColor.cyan</span><br><span class="line">        view.addSubview(testView)</span><br><span class="line">        testView.snp.makeConstraints &#123; (make) in</span><br><span class="line">            make.width.height.equalTo(100)    // 链式语法直接定义宽高</span><br><span class="line">            make.center.equalToSuperview()    // 直接在父视图居中</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-e0670758f7c9b415.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TestPicture1"></p>
<p><strong>2</strong>、View2位于View1内， view2位于View1的中心， 并且距离View的边距的距离都为20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">     </span><br><span class="line">         // 黑色视图作为父视图</span><br><span class="line">         let view1 = UIView()</span><br><span class="line">         view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">         view1.center = view.center</span><br><span class="line">         view1.backgroundColor = UIColor.black</span><br><span class="line">         view.addSubview(view1)</span><br><span class="line">         </span><br><span class="line">         // 测试视图</span><br><span class="line">         let view2 = UIView()</span><br><span class="line">         view2.backgroundColor = UIColor.magenta</span><br><span class="line">         view1.addSubview(view2)</span><br><span class="line">         view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">         	  make.top.equalToSuperview().offset(20)      // 当前视图的顶部距离父视图的顶部：20（父视图顶部+20）</span><br><span class="line">         	  make.left.equalToSuperview().offset(20)     // 当前视图的左边距离父视图的左边：20（父视图左边+20）</span><br><span class="line">              make.bottom.equalToSuperview().offset(-20)  // 当前视图的底部距离父视图的底部：-20（父视图底部-20）</span><br><span class="line">              make.right.equalToSuperview().offset(-20)   // 当前视图的右边距离父视图的右边：-20（父视图右边-20）</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简洁的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">     </span><br><span class="line">         // 黑色视图作为父视图</span><br><span class="line">         let view1 = UIView()</span><br><span class="line">         view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">         view1.center = view.center</span><br><span class="line">         view1.backgroundColor = UIColor.black</span><br><span class="line">         view.addSubview(view1)</span><br><span class="line">         </span><br><span class="line">         // 测试视图</span><br><span class="line">         let view2 = UIView()</span><br><span class="line">         view2.backgroundColor = UIColor.magenta</span><br><span class="line">         view1.addSubview(view2)</span><br><span class="line">         view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">            make.edges.equalToSuperview().inset(UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20))</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-ad6e16114189a9bb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TestPicture2"></p>
<p><strong>3</strong>、布局一个视图view2， 让它的水平中心线小于等于另一个视图view2的左边，可以这样布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">     </span><br><span class="line">         // 黑色视图作为父视图</span><br><span class="line">         let view1 = UIView()</span><br><span class="line">         view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">         view1.center = view.center</span><br><span class="line">         view1.backgroundColor = UIColor.black</span><br><span class="line">         view.addSubview(view1)</span><br><span class="line">        </span><br><span class="line">         // 测试视图</span><br><span class="line">         let view2 = UIView()</span><br><span class="line">         view2.backgroundColor = UIColor.magenta</span><br><span class="line">         view1.addSubview(view2)</span><br><span class="line">         view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">            // 让顶部距离view1的底部为10的距离</span><br><span class="line">            make.top.equalTo(view1.snp.bottom).offset(10)</span><br><span class="line">            // 设置宽、高</span><br><span class="line">            make.width.height.equalTo(100)</span><br><span class="line">            // 水平中心线&lt;=view1的左边</span><br><span class="line">            make.centerX.lessThanOrEqualTo(view1.snp.leading)</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-fda525f8d8d474b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TestPicture"></p>
<h3 id="视图的属性说明"><a href="#视图的属性说明" class="headerlink" title="视图的属性说明"></a>视图的属性说明</h3><p>通过上面的大致简单布局我们对SnapKit有了一个基本的了解，那么， 它的布局属性是怎么来的呢？和原生的布局类有什么关联？ 下面看一个SnapKit的布局属性表</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-98e6cb55d8b7702c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>从表中，我们知道，Snapkit的布局属性都是源自于系统的NSLayoutAttribute，那么，NSLayoutAttribute是个什么呢？其实，它在swift中是一个枚举，内部列举了很多布局属性诸如top、left、leading、centerX等，Snapkit的布局属性与它们都存在一一的对应关系。</p>
<h4 id="Snapkit-的-greaterThanOrEqualTo-属性"><a href="#Snapkit-的-greaterThanOrEqualTo-属性" class="headerlink" title="Snapkit 的 greaterThanOrEqualTo 属性"></a>Snapkit 的 greaterThanOrEqualTo 属性</h4><p>如果想让视图View2的左边&gt;=父视图View1的左边， 这时我们就可以用到greaterThanOrEqualTo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">         // 黑色视图作为父视图</span><br><span class="line">         let view1 = UIView()</span><br><span class="line">         view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">         view1.center = view.center</span><br><span class="line">         view1.backgroundColor = UIColor.black</span><br><span class="line">         view.addSubview(view1)</span><br><span class="line">        </span><br><span class="line">         // 测试视图</span><br><span class="line">         let view2 = UIView()</span><br><span class="line">         view2.backgroundColor = UIColor.magenta</span><br><span class="line">         view1.addSubview(view2)</span><br><span class="line">         view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">            // 让顶部距离view1的底部为10的距离</span><br><span class="line">            make.top.equalTo(view1.snp.bottom).offset(10)</span><br><span class="line">            // 设置宽、高</span><br><span class="line">            make.width.height.equalTo(100)</span><br><span class="line">            // 水平中心线&lt;=view1的左边</span><br><span class="line">            make.left.greaterThanOrEqualTo(view1)</span><br><span class="line">            </span><br><span class="line">            // 或者, 和上面一行代码一样的效果</span><br><span class="line">//            make.left.greaterThanOrEqualTo(view1.snp.left)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-4a58ce03c79222d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TestPicture"></p>
<p>其实，greaterThanOrEqualTo这个属性有点多余，比如上面这行代码 <strong>make.left.greaterThanOrEqualTo(view1)</strong> ， 我们可以换成 <strong>make.left.equalToSuperview()</strong>或<strong>make.left.equalTo(view1.snp.left)</strong>， 效果是一样的，也就是说，一般情况下 <strong>&gt;=</strong> 或 <strong>&lt;=</strong> 我们都可以直接用<strong>equalTo</strong>来代替！</p>
<h4 id="SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用"><a href="#SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用" class="headerlink" title="SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用"></a>SnapKit的greaterThanOrEqualTo和lessThanOrEqualTo联合使用</h4><p>当我们想要让某个视图的<strong>width或height</strong>大于等于某个特定的值，小于等于某个特定的值的时候，一般而言，Snapkit会以greaterThanOrEqualTo为准，这里举一个width的例子，为了方便，这里指贴出了viewDidLoad中的代码（其他没必要）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 黑色视图作为父视图</span><br><span class="line">let view1 = UIView()</span><br><span class="line">view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">view1.center = view.center</span><br><span class="line">view1.backgroundColor = UIColor.black</span><br><span class="line">view.addSubview(view1)</span><br><span class="line">   </span><br><span class="line">// 测试视图</span><br><span class="line">let view2 = UIView()</span><br><span class="line">view2.backgroundColor = UIColor.magenta</span><br><span class="line">view1.addSubview(view2)</span><br><span class="line">view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">   make.width.lessThanOrEqualTo(300)</span><br><span class="line">   make.width.greaterThanOrEqualTo(200)</span><br><span class="line">   make.height.equalTo(100)</span><br><span class="line">   make.center.equalToSuperview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们来看一下效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-09c6303f2d50331c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Test6"></p>
<p>很明显，最后的宽度是以<strong>make.width.greaterThanOrEqualTo(200)</strong>为标准的，也可以这样的，在同时使用两者的情况下，<strong>greaterThanOrEqualTo</strong>的优先级略比<strong>lessThanOrEqualTo</strong>的优先级高。值得一提的是， 在上面的例子中，如果我们只设置<strong>make.width.lessThanOrEqualTo(300)</strong>，那么view2是不会显示出来的，因为view2不知道你要表达的是要显示多少，小于等于300，到底是100还是200呢？(这里指针对width和height）所以它不能确定这个约束的值，但是，如果我们单独设置<strong>make.width.greaterThanOrEqualTo(200)</strong>，那么就和上面的效果一样，因为它会以200为标准布局约束！</p>
<h4 id="lessThanOrEqualTo的用于上、下、左、右"><a href="#lessThanOrEqualTo的用于上、下、左、右" class="headerlink" title="lessThanOrEqualTo的用于上、下、左、右"></a>lessThanOrEqualTo的用于上、下、左、右</h4><p>如果我们想要视图view2的左边 &lt;= view1.left + 10, 那么就可以直接用到<strong>lessThanOrEqualTo</strong>布局了，看下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 黑色视图作为父视图</span><br><span class="line">let view1 = UIView()</span><br><span class="line">view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">view1.center = view.center</span><br><span class="line">view1.backgroundColor = UIColor.black</span><br><span class="line">view.addSubview(view1)</span><br><span class="line">   </span><br><span class="line">// 测试视图</span><br><span class="line">let view2 = UIView()</span><br><span class="line">view2.backgroundColor = UIColor.magenta</span><br><span class="line">view1.addSubview(view2)</span><br><span class="line">view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">   make.left.lessThanOrEqualTo(20)		// &lt;= 父视图的左边+20</span><br><span class="line">   make.right.equalTo(-40)				// = 父视图的右边-40</span><br><span class="line">   make.height.equalTo(100)</span><br><span class="line">   make.center.equalToSuperview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-f85ad9126140abae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Test7"></p>
<h4 id="Snapkit布局的灵活性"><a href="#Snapkit布局的灵活性" class="headerlink" title="Snapkit布局的灵活性"></a>Snapkit布局的灵活性</h4><ul>
<li>Snapkit布局灵活性很强， 我们看下面的例子, 他们的效果是一样的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make.left.equalToSuperview().offset(10)</span><br><span class="line">make.left.equalTo(10)</span><br><span class="line">make.left.equalTo(view1.snp.left).offset(10)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置视图的大小（width，height）,他们效果是一样的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make.width.height.equalTo(100)</span><br><span class="line">或</span><br><span class="line">make.width.equalTo(100)</span><br><span class="line">make.height.equalTo(100)</span><br><span class="line">或</span><br><span class="line">make.size.equalTo(CGSize(width: 100, height: 100))</span><br></pre></td></tr></table></figure>

<ul>
<li>优先级(priority)</li>
</ul>
<p>我们来看一下Snapkit的优先级设置， 优先级都是附加在约束链的末尾处，看下面的使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 黑色视图作为父视图</span><br><span class="line">let view1 = UIView()</span><br><span class="line">view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">view1.center = view.center</span><br><span class="line">view1.backgroundColor = UIColor.black</span><br><span class="line">view.addSubview(view1)</span><br><span class="line">    </span><br><span class="line">// 测试视图</span><br><span class="line">let view2 = UIView()</span><br><span class="line">view2.backgroundColor = UIColor.magenta</span><br><span class="line">view1.addSubview(view2)</span><br><span class="line">view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">	make.width.equalTo(100).priority(666)</span><br><span class="line">	make.width.equalTo(250).priority(999)</span><br><span class="line">	make.height.equalTo(111)</span><br><span class="line">	make.center.equalToSuperview()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-87a1f04f3651a3a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="priorityimage"></p>
<p>从上面我们可以知道, 我们设置了两个优先级：make.width.equalTo(100).priority(666) <strong>和</strong> make.width.equalTo(250).priority(999)， 那运行结果是一个哪个为准呢？显然是以优先级为 <strong>999</strong>的为准，因为 priority(999)&gt;priotity(666)， 所以在使用Snapkit的过程中，有时我们可以使用优先级priority来设置我们的约束， 另外，值得一提的是，SnapKit的优先级最大值只能是 1000， 如果优先级的数值超过1000，则运行时就会<strong>Crash</strong>！这里要尤其注意。</p>
<br>

<ul>
<li>更新约束（引用约束）</li>
</ul>
<br>

<p>我们可以通过保存某一个约束布局来更新相应的约束，或者保存一组约束布局到一个数组中更新约束， 具体看下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 保存约束（引用约束）</span><br><span class="line">var updateConstraint: Constraint?</span><br><span class="line">    </span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    // 黑色视图作为父视图</span><br><span class="line">    let view1 = UIView()</span><br><span class="line">    view1.frame = CGRect(x: 0, y: 0, width: 300, height: 300)</span><br><span class="line">    view1.center = view.center</span><br><span class="line">    view1.backgroundColor = UIColor.black</span><br><span class="line">    view.addSubview(view1)</span><br><span class="line"></span><br><span class="line">    // 测试视图</span><br><span class="line">    let view2 = UIView()</span><br><span class="line">    view2.backgroundColor = UIColor.magenta</span><br><span class="line">    view1.addSubview(view2)</span><br><span class="line">    view2.snp.makeConstraints &#123; (make) in</span><br><span class="line">        make.width.height.equalTo(100)  // 宽高为100</span><br><span class="line">        self.updateConstraint = make.top.left.equalTo(10).constraint   // 距离父视图上、左为10</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let updateButton = UIButton(type: .custom)</span><br><span class="line">    updateButton.backgroundColor = UIColor.brown</span><br><span class="line">    updateButton.frame = CGRect(x: 100, y: 80, width: 50, height: 30)</span><br><span class="line">    updateButton.setTitle(&quot;更新&quot;, for: .normal)</span><br><span class="line">    updateButton.addTarget(self, action: #selector(updateConstraintMethod), for: .touchUpInside)</span><br><span class="line">    view.addSubview(updateButton)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 更新约束</span><br><span class="line">func updateConstraintMethod() &#123;</span><br><span class="line">    self.updateConstraint?.update(offset: 50)   // 更新距离父视图上、左为50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/1974698-5d2e213fdaa51b25.gif?imageMogr2/auto-orient/strip" alt="testgif1"></p>
<ul>
<li>更新约束(snp.updateConstraints)</li>
</ul>
<p>说起这个<code>updateConstraints</code>, 我也懵逼过，那么它到底有何作用呢？又怎么用呢？它和一开始就使用的<code>makeConstraints</code>又有什么明确的区别呢？请继续往下看</p>
<p><strong>说明1</strong>：如果你这是更新某个约束或某几个约束的常量值，你就可以使用<code>updateConstraints</code>而不是<code>makeConstraints</code>。</p>
<p><strong>说明2</strong>：这个也是苹果推荐用来添加或更新约束的方式</p>
<p><strong>说明3</strong>：这个方法可以调用多次，会相应<code>setNeedsUpdateConstraints</code>, 在控制器中，可以写在<code>override func updateViewConstraints()</code>方法里面（当然也可以写在你想要什么时候更新的点击事件里面）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import SnapKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    lazy var blackView = UIView()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        blackView.backgroundColor = UIColor.black</span><br><span class="line">        view.addSubview(blackView)</span><br><span class="line">        blackView.snp.makeConstraints &#123; (make) in</span><br><span class="line">            </span><br><span class="line">            // 四个约束确定位置和大小</span><br><span class="line">            make.width.equalTo(100)</span><br><span class="line">            make.height.equalTo(150)</span><br><span class="line">            make.top.equalTo(10)</span><br><span class="line">            make.centerX.equalToSuperview()</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func updateViewConstraints() &#123;</span><br><span class="line">        </span><br><span class="line">        blackView.snp.updateConstraints &#123; (make) in</span><br><span class="line">            // 更新距离父视图顶部的约束（从 10 ---&gt; 300 ）</span><br><span class="line">            make.top.equalTo(300)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据苹果，调用父类应该放在末尾</span><br><span class="line">        super.updateViewConstraints()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>注意</code>: 从上面的代码中我们很明确地知道， <code>blackView</code>通过<code>width</code>、<code>height</code>、<code>top</code>、<code>centerX</code>确定了它本身的大小和位置， 但是， 在 run 出来之后，它的top改变了距离， 从 10 变成了 300，其他三个约束保持不变， 见下图效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-f26b2286347c39cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test10"></p>
<p>显而易见， 除了<code>top</code>约束， 其他都没有改变！ 也就是说，约束被更新（相当于系统升级一样，是一个道理）</p>
<p>现在，我们通过UIButton的点击事件来证明一下制作约束<code>makeConstraints</code>和<code>updateConstraints</code><strong>具体的区别</strong>在哪里？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var blackView = UIView()</span><br><span class="line">    </span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    blackView.backgroundColor = UIColor.black</span><br><span class="line">    view.addSubview(blackView)</span><br><span class="line">    blackView.snp.makeConstraints &#123; (make) in</span><br><span class="line">        </span><br><span class="line">        make.width.equalTo(100)</span><br><span class="line">        make.height.equalTo(150)</span><br><span class="line">        make.top.equalTo(50)</span><br><span class="line">        make.centerX.equalToSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let btn = UIButton(type: .custom)</span><br><span class="line">    btn.backgroundColor = UIColor.brown</span><br><span class="line">    btn.frame = CGRect(x: 100, y: 200, width: 60, height: 30)</span><br><span class="line">    btn.addTarget(self, action: #selector(buttonAction), for: .touchUpInside)</span><br><span class="line">    view.addSubview(btn)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 点击更新/制作约束</span><br><span class="line">func buttonAction() &#123;</span><br><span class="line">    </span><br><span class="line">    blackView.snp.makeConstraints &#123; (make) in</span><br><span class="line">        make.width.height.equalTo(20)</span><br><span class="line">        make.top.equalTo(300)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看效果图</p>
<p><strong>点击事件发生前(图1）：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-9a709cc7bfd4a9e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test11"></p>
<p><strong>点击事件发生后（图2）</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-e5f347e060f611f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test12"></p>
<p><strong>图3</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-a8eb71769d210970.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test14"></p>
<p><strong>图4</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-ca57e8436580500d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test13"></p>
<blockquote>
<p>上面，我们知道，视图 <strong>blackView</strong>一开始是由四个约束确定位置和大小，在点击事情响应后，我们又给 <strong>blackView</strong> 制作（记住，是制作，而不是重做，两者有明确的区别）了3个约束，分别是 <code>width</code>、<code>height</code>、<code>top</code>, 那么这样做问题出现在哪里呢？ <strong>第一</strong>， 点击事情发生前（图1）， 在点击事件发生后（见图2）， 我们发现，<code>blackView</code>的<code>width</code>、<code>height</code>约束改变了，但是 <code>top</code>却没有改变，还是原来的距离父视图顶部 50 的距离， 原因在于，我们在原来的约束基础上又添加了<strong>多余的</strong>约束， 也就是说，约束从4个变成了7个（见图3左边constraints）， 这样就产生了约束不明确，进而导致<strong>snapkit</strong>的警告（见图4）， 这样布局显然是不可取的，在项目中这样做极其危险，甚至可能会导致异常奔溃！！！！</p>
</blockquote>
<p><strong>现在</strong>， 我们该将点击事件中的约束布局从<code>makeConstraints</code>改变成<code>updateConstraints</code>来试试两者有什么区别(下面只添加了点击事件的代码，其他事重复的就不多此一举了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func buttonAction() &#123;</span><br><span class="line">    // 注意这里是updateConstraints， 而不是makeConstraints</span><br><span class="line">    blackView.snp.updateConstraints &#123; (make) in</span><br><span class="line">        make.width.height.equalTo(20)</span><br><span class="line">        make.top.equalTo(300)</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;这里试试snapkit有没有报警告&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看点击事件后的效果图</p>
<p><strong>图5</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-d3ad7232e8a70246.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test5"></p>
<p><strong>图6</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-a0d9f2b52521f740.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test6"></p>
<p><strong>图7</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-1e9f584ce592812c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test7"></p>
<blockquote>
<p>发现没有，在将<code>makeConstraints</code>改变成<code>updateConstraints</code>之后，约束还是4个，snapkit没有报警告，点击事件中的<code>width</code>、<code>height</code>、<code>top</code>全部起了作用，而这就是两者的<strong>本质区别</strong>：<code>makeConstraints</code>是制作约束，在原来的基础上再添加另外的约束，也就是画蛇添足，约束增加，视图布局就有不确定性，从而有些约束起作用，有些不起作用（如上面的top），snapkit报警告！！！而<code>updateConstraints</code>是更新约束，改变原有约束，约束不会增加，没经过<code>updateConstraints</code>处理的保持原有约束，经过处理就更新约束，约束不会减少，snapkit不会产生警告，这是正常标准的更新约束的正确方式！！！</p>
</blockquote>
<br>

<ul>
<li>重做约束（remakeConstraints）</li>
</ul>
<p>重做约束的本质就是：去掉已有的<strong>所有约束</strong>， 重新做约束，记住，是做约束， 也就是说， 使用了<code>remakeConstraints</code>后，重做的约束必须要能确定相应视图的<strong>大小</strong>和<strong>位置</strong>, 之前<code>makeConstraints</code>的约束已经不会存在了，完全销毁！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 点击更新/制作约束</span><br><span class="line">func buttonAction() &#123;</span><br><span class="line">    </span><br><span class="line">    // 注意这里是 remakeConstraints</span><br><span class="line">    blackView.snp.remakeConstraints &#123; (make) in</span><br><span class="line">        make.width.height.equalTo(20)</span><br><span class="line">        make.top.equalTo(300)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print(&quot;这里试试snapkit有没有报警告&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果图</strong></p>
<p><strong>图（1）</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-5fd5a69571c14dd0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test18"></p>
<p><strong>图（2）</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-d5f4714041562066.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test19"></p>
<p><strong>图（3）</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1974698-bbf3ddc34397a09b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test20"></p>
<blockquote>
<p>我们看到， <code>blackView</code>重做了约束， 之前的约束不起任何作用，由于它在重做约束后只有 3 个约束分别是 <code>width</code>、<code>height</code>、<code>top</code>, 但是这里有一个问题，就是这 3 个约束只能确定大小，无法确定视图的位置， 所以在水平方向上或者左右缺少一个布局条件， 故 <code>blackView</code>整体视图的x紧靠左边（默认）！ 另外我们发现， 在<strong>图（3）</strong>中，右上角出现了一个感叹号“！”, 那是因为告诉你缺少了一个约束条件：<code>x-xcode-debug-views://7f81fcbc7900: runtime: Layout Issues: Horizontal position is ambiguous for UIView.</code></p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过以上学习，我们或深或浅地学习了布局三方库SnapKit的使用， 我相信，只要将上述布局会使用，并且懂得布局的原则和道理，基本上就可以“高枕无忧”了，至于涉及动态布局、动画布局等知识，后续有时间会更新文档。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Autolayout</tag>
        <tag>Snapkit</tag>
        <tag>自动布局</tag>
        <tag>UI</tag>
      </tags>
  </entry>
</search>
